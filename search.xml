<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[PBRT（Chapter1）]]></title>
      <url>/2019/11/05/PBRT_Learning_1/</url>
      <content type="html"><![CDATA[<h1 id="PBRT-CHAPTER-1"><a href="#PBRT-CHAPTER-1" class="headerlink" title="PBRT CHAPTER_1"></a>PBRT CHAPTER_1</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>PBRT(Physically Based Rendering Toolkit)<br>基于物理渲染</p>
<p>渲染是根据三维场景的描述生成图像的过程。显然，这是一个非常广泛的任务，有许多方法可以实现它。基于物理的技术试图模拟现实;也就是说，他们使用物理原理来模拟光和物质的相互作用。虽然基于物理的方法似乎是处理呈现的最明显的方法，但它只是在过去10年左右的实践中才被广泛采用。<br>学习基于PBRT-v3<br>友情链接：<br>（一）PBRT-v3在线电子书：<a href="http://www.pbr-book.org/3ed-2018/contents.html" target="_blank" rel="noopener">http://www.pbr-book.org/3ed-2018/contents.html</a><br>（二）实验室学长的PBRT-v3配置教程: <a href="https://fancyvin.github.io/2019/07/13/how-to-compile-pbrt-v3-renderer/" target="_blank" rel="noopener">https://fancyvin.github.io/2019/07/13/how-to-compile-pbrt-v3-renderer/</a></p>
<h2 id="1-1-Literate-Programming-文学编程"><a href="#1-1-Literate-Programming-文学编程" class="headerlink" title="1.1 Literate Programming 文学编程"></a>1.1 Literate Programming 文学编程</h2><h2 id="1-2-Photorealistic-Rendering-and-the-Ray-Tracing-Algorithm-照片级渲染及光线跟踪算法"><a href="#1-2-Photorealistic-Rendering-and-the-Ray-Tracing-Algorithm-照片级渲染及光线跟踪算法" class="headerlink" title="1.2 Photorealistic Rendering and the Ray-Tracing Algorithm 照片级渲染及光线跟踪算法"></a>1.2 Photorealistic Rendering and the Ray-Tracing Algorithm 照片级渲染及光线跟踪算法</h2><h4 id="1-2-1-Camera相机"><a href="#1-2-1-Camera相机" class="headerlink" title="1.2.1 Camera相机"></a>1.2.1 Camera相机</h4><ul>
<li><p>针孔相机<br>  胶片Film    针孔Pinhole   视见体Viewing Volume</p>
<h4 id="1-2-2-Ray-Object-Intersection光线-对象相交"><a href="#1-2-2-Ray-Object-Intersection光线-对象相交" class="headerlink" title="1.2.2 Ray-Object Intersection光线-对象相交"></a>1.2.2 Ray-Object Intersection光线-对象相交</h4></li>
<li><p>当相机生成一条光线时，renderer的首要任务是：确定与光线intersect的首个对象和相交的位置。This intersection point is the visible point along the ray, and we will want to simulate the intersection of light with the object at this point. </p>
</li>
<li><figure class="image-box">
                <img src="1.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>
<p>  给定光线r,o为光线源点，d表示方向向量，参数t的范围为0到无穷，通过t取不同的值可以得到光线上的任何一点。<br>  在交点的计算中，需测试光线与全部场景对象之间的相交结果，并选取与光线首次相交的对象。<br>  多数场景均由多个对象构成，蛮力进行相机计算将依次测试场景中的各个对象，并选取相交结果最小的t值，但这种方案的计算速度较为缓慢；还可以引入加速结构，并剔除一组对象，进行算法的加速。</p>
</li>
</ul>
<h4 id="1-2-3-Light-Distribution光照分布"><a href="#1-2-3-Light-Distribution光照分布" class="headerlink" title="1.2.3 Light Distribution光照分布"></a>1.2.3 Light Distribution光照分布</h4><ul>
<li><figure class="image-box">
                <img src="2.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure></li>
<li>较大球体上某点处的能量将小于较小球体，其原因在于相同的光能分布于较大的面积上，特别的，对于半径为r的球体，其表面某点处的能量与1/r^2成比例。</li>
<li>由于点光源采用各向均等方式辐射能量。因而两球体存储相同光能。</li>
<li>对于球体表面面积微分dA,其上的光能能够表示为：<figure class="image-box">
                <img src="3.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure><br>其中Φ表示光源能量，θ为表面点法线与表面点和光源连线的夹角</li>
<li><figure class="image-box">
                <img src="4.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>


</li>
</ul>
<h4 id="1-2-4Visibility-可见性"><a href="#1-2-4Visibility-可见性" class="headerlink" title="1.2.4Visibility 可见性"></a>1.2.4Visibility 可见性</h4><ul>
<li>确定是否被遮挡（阴影）</li>
<li>当着色点与光源之间没有遮挡时，着色点方可被“点亮”<br>确定是否被遮挡：</li>
<li>1、着色点与光源之间的连线，指向光源——阴影光线（shaow rays）</li>
<li>2、通过交点计算，算出参数t,确定阴影光线的交点，并通过t的值，确定遮挡关系</li>
</ul>
<h4 id="1-2-5表面散射-Surface-Scattering"><a href="#1-2-5表面散射-Surface-Scattering" class="headerlink" title="1.2.5表面散射 Surface Scattering"></a>1.2.5表面散射 Surface Scattering</h4><p>场景中的各对象的材质属性，描述了表面各点处的外观属性，材质通过BRDF定义（双向反射分布函数）</p>
<ul>
<li><figure class="image-box">
                <img src="5.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>
参数含义：</li>
<li><figure class="image-box">
                <img src="6.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>    
<h4 id="1-2-6-Indirect-Light-Transport"><a href="#1-2-6-Indirect-Light-Transport" class="headerlink" title="1.2.6 Indirect Light Transport"></a>1.2.6 Indirect Light Transport</h4></li>
<li><figure class="image-box">
                <img src="7.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>

</li>
</ul>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=501468332&auto=1&height=32"></iframe>
]]></content>
      
        <categories>
            
            <category> Computer-Science </category>
            
            <category> RayTracing </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RayTracing </tag>
            
            <tag> PBRT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++学习（二）]]></title>
      <url>/2019/11/05/C++_Learning_2/</url>
      <content type="html"><![CDATA[<h1 id="1-C-重载操作符operator"><a href="#1-C-重载操作符operator" class="headerlink" title="1. C++重载操作符operator"></a>1. C++重载操作符operator</h1><h2 id="1-1-what："><a href="#1-1-what：" class="headerlink" title="1. 1 what："></a>1. 1 what：</h2><p>C++中的一个关键字，和运算符（例如=）一起使用，表示一个运算符重载函数，使扩展后的运算符的使用方法与重载前一致。</p>
<h2 id="1-2-why"><a href="#1-2-why" class="headerlink" title="1.2 why:"></a>1.2 why:</h2><p>C++提供的所有运算符只能支持对于基本数据类型以及标准库中提供的类的操作，而对于用户自己定义的类，如果想要通过操作符进行一些基本操作（比如：大小比较，相等判断等），需要用户自己定义操作符的具体实现。</p>
<h2 id="1-3-how-两种方式："><a href="#1-3-how-两种方式：" class="headerlink" title="1.3 how:两种方式："></a>1.3 how:两种方式：</h2><h3 id="1-3-1将操作符重载实现为类的成员函数"><a href="#1-3-1将操作符重载实现为类的成员函数" class="headerlink" title="1.3.1将操作符重载实现为类的成员函数"></a>1.3.1将操作符重载实现为类的成员函数</h3><p><strong>在类体中声明需要重载的操作符时，声明方式跟普通的成员函数一样</strong></p>
<blockquote>
<p>//类结构中被声明的函数<br>bool operator==(const person&amp; ps) //person为自己定义的类<br>｛<br>        If（this-&gt;age == ps.age）{<br>           return true;<br>       }<br>       return false;<br>｝</p>
</blockquote>
<h3 id="1-3-2将操作符重载为非类的成员函数（即：全局函数）"><a href="#1-3-2将操作符重载为非类的成员函数（即：全局函数）" class="headerlink" title="1.3.2将操作符重载为非类的成员函数（即：全局函数）"></a>1.3.2将操作符重载为非类的成员函数（即：全局函数）</h3><p>** 对于全局重载操作符，代表左操作数的参数必须被显式指定  **</p>
<blockquote>
<p>//全局函数<br>bool operator==(person const &amp; p1,person const &amp; p2);<br>{<br>   if(p1.age==p2.age){<br>       return true;<br>   }<br>   return false;<br>}</p>
</blockquote>
<p>‘ 其中person的定义如下：’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class person&#123;</span><br><span class="line">	public :</span><br><span class="line">		int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="2-C-中修饰符-inline-表示内联函数"><a href="#2-C-中修饰符-inline-表示内联函数" class="headerlink" title="2.  C++中修饰符 inline,表示内联函数"></a>2.  C++中修饰符 inline,表示内联函数</h1><ul>
<li><h2 id="2-1-what"><a href="#2-1-what" class="headerlink" title="2.1 what:"></a>2.1 what:</h2><p>修饰为内联函数</p>
</li>
<li><h2 id="2-2-why"><a href="#2-2-why" class="headerlink" title="2.2 why:"></a>2.2 why:</h2><p>为了解决<strong>频繁调用</strong>的小函数大量消耗栈空间的问题<br>（栈空间：放置程序的局部数据的内存空间）<br>避免频繁调用函数对栈空间重复开辟所带来的消耗</p>
</li>
<li><h2 id="2-3-how"><a href="#2-3-how" class="headerlink" title="2.3 how:"></a>2.3 how:</h2></li>
<li><figure class="image-box">
                <img src="wps1.jpg" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>

</li>
</ul>
<p>inline使用限制：inline修饰的函数只适合于函数内部简单，没有包含复杂的逻辑结构，例如：while,switch，同时inline修饰的函数还不能自己调用自己。 </p>
<p>建议inline函数的定义放置于头文件中</p>
<p>定义在类中的函数都是默认内联的，如果需要将类中的方法写于类结构之外，而又想为内联函数，则需要显式声明为inline</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//定义于类结构之内的函数默认为内联函数</span><br><span class="line">void Foo(int x,int y)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果需要定义于类结构之外的内联函数</span><br><span class="line">inline void  A::Foo(int x,int y)&#123;&#125;</span><br><span class="line">//同时需要注意的是，inline必须于函数定义放置一起</span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      
        <categories>
            
            <category> Computer-Science </category>
            
            <category> Programming Language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Programming Language </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++学习（一）]]></title>
      <url>/2019/11/05/C++_Learning_1/</url>
      <content type="html"><![CDATA[<h3 id="1-使用-ifdef和-pragam-once两种方式避免一个文件被include多次"><a href="#1-使用-ifdef和-pragam-once两种方式避免一个文件被include多次" class="headerlink" title="1. 使用#ifdef和#pragam once两种方式避免一个文件被include多次"></a>1. 使用#ifdef和#pragam once两种方式避免一个文件被include多次</h3><p><em>(不要拼措了，是pragam，不是program)</em></p>
<p>#ifdef受到C/C++语言标准支持，不会受到编译器的限制，而#pragma once一般由编译器提供保证。</p>
<p>#pragma once 的兼容性不如#if def</p>
<h3 id="2-定义类结构时，需要显式public参数或方法"><a href="#2-定义类结构时，需要显式public参数或方法" class="headerlink" title="2. 定义类结构时，需要显式public参数或方法"></a>2. 定义类结构时，需要显式public参数或方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class vec3&#123;</span><br><span class="line">	public:</span><br><span class="line">		float e[3];</span><br><span class="line">	</span><br><span class="line">	vec3()&#123;&#125;</span><br><span class="line">	vec3(float e1, float e2,float e3)&#123;</span><br><span class="line">		e[0] = e1;</span><br><span class="line">		e[1] = e2;</span><br><span class="line">		e[2] = e3;</span><br><span class="line">&#125;</span><br><span class="line">	inline float r()&#123;</span><br><span class="line">		return e[0];</span><br><span class="line">	&#125;</span><br><span class="line">	inline float g()&#123;</span><br><span class="line">		return e[1];</span><br><span class="line">	&#125;</span><br><span class="line">	inline float b()&#123;</span><br><span class="line">		return e[2];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-dot-A-B"><a href="#3-dot-A-B" class="headerlink" title="3.  dot(A ,B)"></a>3.  dot(A ,B)</h3><h5 id="可以进行点乘运算"><a href="#可以进行点乘运算" class="headerlink" title="可以进行点乘运算"></a><em>可以进行点乘运算</em></h5><h3 id="4-基本运算函数"><a href="#4-基本运算函数" class="headerlink" title="4.基本运算函数"></a>4.基本运算函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pow(a，b)幂运算</span><br><span class="line">sqrt(a)开平方根</span><br><span class="line">abs(a)整数求绝对值</span><br><span class="line">fabs(a)浮点数求绝对值</span><br></pre></td></tr></table></figure>


<h3 id="5-基类和派生类"><a href="#5-基类和派生类" class="headerlink" title="5. 基类和派生类"></a>5. 基类和派生类</h3><blockquote>
<p>class derived-class  :  access-specifier base-class<br>//derived-class 派生类   base-class 基类  access-specifer 访问修饰符（private ,public, &gt;protected）<br>eg   class Dustman: public Worker</p>
<ul>
<li><strong>如果没有使用访问修饰符，那么默认为private</strong> </li>
</ul>
</blockquote>
<h3 id="6-纯虚函数"><a href="#6-纯虚函数" class="headerlink" title="6. 纯虚函数"></a>6. 纯虚函数</h3><ul>
<li>纯虚函数没有函数体<blockquote>
<p>class shape{<br>public:<br> <strong>virtual double calcPerimeter()=0//纯虚函数</strong><br>}</p>
</blockquote>
</li>
<li>不可实例化含有虚函数的基类</li>
<li></li>
</ul>
<h3 id="7-抽象类"><a href="#7-抽象类" class="headerlink" title="7. 抽象类"></a>7. 抽象类</h3><ul>
<li>抽象类无法实例化对象</li>
</ul>
<h3 id="8-rand-函数"><a href="#8-rand-函数" class="headerlink" title="8. rand()函数"></a>8. rand()函数</h3><ul>
<li>rand()不需要参数，它会返回一个从0到最大随机数的任意整数，</li>
<li>如果你要产生一个0~99这100个整数的一个随机整数，可以表达为:<blockquote>
<p>int num=rand()%100;</p>
</blockquote>
</li>
<li>如果要产生一个1~100这100个整数的一个随机整数，可以表达为：<blockquote>
<p>int num=rand()%100+1;</p>
</blockquote>
</li>
</ul>
<h3 id="9-基础"><a href="#9-基础" class="headerlink" title="9. 基础"></a>9. 基础</h3><p>+++</p>
<ul>
<li><figure class="image-box">
                <img src="QQ截图20191016101925.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>
<h4 id="C-是面向对象程序设计语言"><a href="#C-是面向对象程序设计语言" class="headerlink" title="C++是面向对象程序设计语言"></a>C++是面向对象程序设计语言</h4><p>C++全面支持面向对象开发四大特性：</p>
</li>
<li><p>封装</p>
</li>
<li><p>抽象</p>
</li>
<li><p>继承</p>
</li>
<li><p>多态</p>
</li>
</ul>
<h4 id="七种基本数据类型"><a href="#七种基本数据类型" class="headerlink" title="七种基本数据类型"></a>七种基本数据类型</h4><ul>
<li>布尔值 bool</li>
<li>字符型 char</li>
<li>整型 int</li>
<li>浮点型 float</li>
<li>双浮点型 double</li>
<li>无类型 void</li>
<li>宽字符型 wchar_t</li>
</ul>
<h4 id="类型修饰符"><a href="#类型修饰符" class="headerlink" title="类型修饰符"></a>类型修饰符</h4><ul>
<li>signed</li>
<li>long</li>
<li>short</li>
<li>unsigned</li>
</ul>
<h4 id="使用sizeof-获取数据类型长度："><a href="#使用sizeof-获取数据类型长度：" class="headerlink" title="使用sizeof()获取数据类型长度："></a>使用sizeof()获取数据类型长度：</h4><ul>
<li><figure class="image-box">
                <img src="QQ截图20191016105451.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>

</li>
</ul>
<h4 id="使用typedef关键字为一个已有的数据类型取一个新的名字（别名）"><a href="#使用typedef关键字为一个已有的数据类型取一个新的名字（别名）" class="headerlink" title="使用typedef关键字为一个已有的数据类型取一个新的名字（别名）"></a>使用typedef关键字为一个已有的数据类型取一个新的名字（别名）</h4><blockquote>
<p>typedef int fet;  //告诉编译器 fet是int的别名<br>fet a;  //使用别名声明变量</p>
</blockquote>
<h4 id="枚举类型（enumeration）是C-中一个派生的数据类型"><a href="#枚举类型（enumeration）是C-中一个派生的数据类型" class="headerlink" title="枚举类型（enumeration）是C++中一个派生的数据类型"></a>枚举类型（enumeration）是C++中一个派生的数据类型</h4><ul>
<li><p>由用户定义的若干枚举常量的集合</p>
</li>
<li><figure class="image-box">
                <img src="test1.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>

</li>
</ul>
<h4 id="extern关键字在任何地方声明变量"><a href="#extern关键字在任何地方声明变量" class="headerlink" title="extern关键字在任何地方声明变量"></a>extern关键字在任何地方声明变量</h4><ul>
<li></li>
</ul>
<h4 id="局部变量，全局变量"><a href="#局部变量，全局变量" class="headerlink" title="局部变量，全局变量"></a>局部变量，全局变量</h4><ul>
<li><p>全局变量：在所有函数外部定义的变量（通常在函数头部） 全局变量的值在程序的整个生命周期内都是有效的。全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。</p>
</li>
<li><p>局部变量：局部变量只能被函数内部或者代码块内部的语句使用。</p>
</li>
<li><figure class="image-box">
                <img src="test2.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>


</li>
</ul>
<h4 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h4><blockquote>
<p>float a= 3.14159<br>float b=314159E-5L //科学计数法写法</p>
</blockquote>
<h4 id="define-预处理器"><a href="#define-预处理器" class="headerlink" title="#define 预处理器"></a>#define 预处理器</h4><h4 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h4><ul>
<li>const关键字修饰的对象在程序执行期间不能被修改改变</li>
</ul>
<h4 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C++存储类"></a>C++存储类</h4><ul>
<li><p>C++存储类定义C++程序中 变量或函数的可见性和生命周期</p>
</li>
<li><p>register 存储类：用于定义在寄存器中而不是内存中的局部变量</p>
<blockquote>
<p> register int miles; //for example</p>
</blockquote>
</li>
<li><p>static存储类：表示编译器在程序的生命周期中保持局部变量的存储，而不需要在每次进入或离开作用域时创建或销毁。即：使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</p>
</li>
<li><p>static 修饰符也可以用于修饰全局变量，这会使变量的作用域限制在声明它的文件内</p>
</li>
<li><p>当 static 用在类数据成员上时，会使<strong>仅有一个</strong>该成员的<strong>副本</strong>被 当 static 用在类数据成员上时，会使仅有一个该成员的副本被类的所有对象共享。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">void func(void);</span><br><span class="line">static int count = 5;//全局静态变量</span><br><span class="line"></span><br><span class="line">void func( void )</span><br><span class="line">&#123;</span><br><span class="line">   static int i = 5; // 局部静态变量</span><br><span class="line">   i++;</span><br><span class="line">   std::cout &lt;&lt; &quot;变量 i 为 &quot; &lt;&lt; i ;</span><br><span class="line">   std::cout &lt;&lt; &quot; , 变量 count 为 &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   while(count--)</span><br><span class="line">   &#123;</span><br><span class="line">      func();</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<ul>
<li><figure class="image-box">
                <img src="test3.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>



</li>
</ul>
<ul>
<li><strong>extern 存储类</strong>：用来在另一个文件中声明一个全局变量和函数</li>
<li>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。</li>
<li><strong>使用 extern 时，对于没有初始化的变量，会把变量名指向一个之前定义过的存储位置。</strong></li>
<li>当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用extern 来得到已定义的变量或函数的引用。</li>
<li>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数</li>
</ul>
<p>main.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int count ;</span><br><span class="line">extern void write_extern();</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   count = 4;</span><br><span class="line">   write_extern();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>support.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">extern int count;</span><br><span class="line">void write_extern(void)</span><br><span class="line">&#123;</span><br><span class="line">   std::cout &lt;&lt; &quot;Count is &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>thread_local存储类：<strong>修饰的变量仅可在它在其上创建的线程上访问。</strong></li>
<li>变量在创建线程时创建，并在销毁线程时销毁。</li>
<li>每个线程都有其自己的变量副本。</li>
<li>thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</li>
</ul>
<h4 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C++ 运算符"></a>C++ 运算符</h4><ul>
<li>&amp; ：指针运算符，返回变量的地址。</li>
<li>* ：指针运算符，指向一个变量。</li>
</ul>
<h4 id="C-函数调用形式"><a href="#C-函数调用形式" class="headerlink" title="C++函数调用形式"></a>C++函数调用形式</h4><table>
<thead>
<tr>
<th>调用类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>传值调用</td>
<td>把参数的实际值复制给函数的形式参数<br/>在这种情况下，修改函数内的形式参数对实际参数没有影响</td>
</tr>
<tr>
<td><strong>指针调用</strong></td>
<td>把参数的地址复制给形式参数<br/>在函数内，该地址用于访问调用中要用到的实际参数<br/>这意味着，修改形式参数会影响实际参数</td>
</tr>
<tr>
<td><strong>引用调用</strong></td>
<td>把参数的引用复制给形式参数<br/>在函数内，该引用用于访问调用中要用到的实际参数<br/>这意味着，修改形式参数会影响实际参数</td>
</tr>
</tbody></table>
<ul>
<li>默认情况下，C++ 使用 传值调用 来传递参数，这意味着函数内的代码不能改变用于调用函数的参数</li>
</ul>
<h4 id="C-Lambda函数"><a href="#C-Lambda函数" class="headerlink" title="C++　Lambda函数"></a>C++　Lambda函数</h4><p>未看</p>
<h4 id="C-数组"><a href="#C-数组" class="headerlink" title="C++ 数组"></a>C++ 数组</h4><ol>
<li><p>初始化：</p>
<blockquote>
<p>/*第一种：逐个初始化数组*/<br>double arr[3];<br>arr[0]=1;<br>arr[1]=2;<br>arr[2]=3;<br>/*第二种：声明的同时使用｛｝初始化数组*/<br>double arr[]={1,2,3}; //或 double arr[3]={1,2,3};</p>
</blockquote>
</li>
<li><p>多维数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//二维数组的初始化</span><br><span class="line">int a[3][4] = &#123;  </span><br><span class="line"> &#123;0, 1, 2, 3&#125; ,   /*  初始化索引号为 0 的行 */</span><br><span class="line"> &#123;4, 5, 6, 7&#125; ,   /*  初始化索引号为 1 的行 */</span><br><span class="line"> &#123;8, 9, 10, 11&#125;   /*  初始化索引号为 2 的行 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传递数组给函数（三种形式）</p>
</li>
</ol>
<ul>
<li><p>形式参数是一个指针：</p>
<blockquote>
<p>void myFunction(int * parm){}</p>
</blockquote>
</li>
<li><p>形式参数是一个已定义大小的数组：</p>
<blockquote>
<p>void myFunction(int parm[10]){}</p>
</blockquote>
</li>
<li><p>形式参数是一个未定义大小的数组：</p>
<blockquote>
<p>void myFunction(int []parm){}</p>
</blockquote>
</li>
</ul>
<p>*<em>这三种声明方式的结果是一样的，因为每种方式都会告诉编译器将要接收一个整型指针 *</em></p>
<ol start="4">
<li>函数返回数组</li>
</ol>
<ul>
<li><p>C++不允许函数返回一个完整的数组 比如：int [] myFunction(){}是错误的</p>
</li>
<li><p>但是可以指定不带索引的数组名来返回一个指向数组的指针，</p>
<blockquote>
<p>void * myFunction(){} //正确</p>
</blockquote>
</li>
<li><p>C++不支持在函数外返回局部变量的地址，除非局部变量是static变量<br>例如：int * myFunction(){<br>  int arr[] myarr;<br>  return myarr; // 错误，不能返回局部变量<br>}</p>
<blockquote>
<p>int * myFunction(){<br>   static int arr[] myarr;<br>   return myarr; // 可以，因为是静态局部变量<br>}</p>
</blockquote>
</li>
<li><p>*得到的是对应地址的值，&amp; 得到的是相应的地址</p>
</li>
<li><figure class="image-box">
                <img src="test4.png" alt="[sorry,图片挂了]" title="[程序截图]" class="[samll]">
                <p>[程序截图]</p>
            </figure>
</li>
<li><figure class="image-box">
                <img src="test5.png" alt="[sorry,图片挂了]" title="[程序截图]" class="[samll]">
                <p>[程序截图]</p>
            </figure>


</li>
</ul>
<h4 id="C-指针"><a href="#C-指针" class="headerlink" title="C++ 指针"></a>C++ 指针</h4><ul>
<li>变量是对程序中数据存储空间的一种抽象</li>
<li>内存中的每个字节都有一个编号——地址<h5 id="取地址符-amp"><a href="#取地址符-amp" class="headerlink" title="取地址符&amp;"></a><strong>取地址符&amp;</strong></h5>取地址符&amp;获得一个变量的内存地址</li>
</ul>
<h5 id="解地址符"><a href="#解地址符" class="headerlink" title="解地址符*"></a><strong>解地址符*</strong></h5><p>解地址符*获得一个内存地址保存的值</p>
<ul>
<li>指针是一个变量，其值为<strong>另一个变量的地址</strong>，即：内存位置的直接地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int    *ip;    /* 一个整型的指针 */</span><br><span class="line">double *dp;    /* 一个 double 型的指针 */</span><br><span class="line">float  *fp;    /* 一个浮点型的指针 */</span><br><span class="line">char   *ch;    /* 一个字符型的指针 */</span><br></pre></td></tr></table></figure>

<ul>
<li>所有指针的值的实际数据类型都是一样的，都是一个代表内存地址的长的16进制数 </li>
<li>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同</li>
</ul>
<h5 id="C-中指针的五种操作"><a href="#C-中指针的五种操作" class="headerlink" title="C++中指针的五种操作"></a>C++中指针的五种操作</h5><ul>
<li><em>1.定义一个指针变量</em><blockquote>
<p>int *ptr_a;</p>
</blockquote>
</li>
<li><em>2.把变量地址赋给指针，使用取地址符</em><blockquote>
<p>int pi = 3.1415926;<br>int <em>ptr_pi = &pi; //这里的</em>是声明指针并不是取解地址符</p>
</blockquote>
</li>
<li><em>3.访问指针变量中可用地址的值，使用解地址符</em><blockquote>
<p>int pi = 3.1415926;<br>int *ptr_pi = &pi;<br>std::cout &lt;&lt; *ptr_pi;</p>
</blockquote>
</li>
<li>4.简单的自增自减和加法减法运算符<br>因为指针保存的是变量的地址，而变量的地址是十六进制整形，所以也支持四种操作，而且只支持这四种</li>
<li>5.简单的比较两个指针的大小,可以使用三个比较运算符 ==、&lt; 和 &gt;<br>这三个比较运算符用于比较指针指向的内存地址是否相等，是否大于或小于</li>
</ul>
<h4 id="C-编程范例"><a href="#C-编程范例" class="headerlink" title="C++编程范例"></a>C++编程范例</h4><ul>
<li><ol>
<li>NULL空指针<br>声明指针变量的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯</li>
</ol>
</li>
</ul>
<ul>
<li>2.指针VS数组<br>C++ 中的指针和数组是密切相关的，指针和数组在很多情况下是可以互换的<br>一个指向数组开头的指针，可以通过使用指针的算术运算或数组索引来访问数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> #include  &lt;iostream&gt;</span><br><span class="line">  const int LEN=5;</span><br><span class="line"> int main()&#123;</span><br><span class="line">	int arr[LEN]=&#123;8,16,32,64,128&#125;;</span><br><span class="line">	//定义指针指向数组地址</span><br><span class="line">	int *ptr=arr;</span><br><span class="line">	//还可以将上一行代替为：int *ptr;   ptr=arr;</span><br><span class="line">	for(int i=0;i&lt;LEN;i++)&#123;</span><br><span class="line">		std::cout  &lt;&lt; &quot;arr[&quot; &lt;&lt; i &lt;&lt; &quot;]的内存地址为 &quot;;</span><br><span class="line">	    std::cout &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line">	    std::cout &lt;&lt; &quot;var[&quot; &lt;&lt; i &lt;&lt; &quot;] 的值为 &quot;;</span><br><span class="line">	    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">	    // 移动到下一个位置</span><br><span class="line">	    ptr++;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>但是<br>指针和数组并不是完全互换的，就是数组变量是不能做自增自减和加减法赋值给自己<br>    int  arr[LEN] = {8, 16, 32,64,128};<br>    for (int i = 0; i &lt; MAX; i++)<br>    {<br>        *arr = i;    // 这是正确的语法<br>        arr++;       // 这是不正确的<br>    }<br>//即：数组名可以指向数组第一个元素地址，可以当作指针使用<br>//但是不能够改变数组名指向数组第一元素的事实    </p>
<ul>
<li><p>3.指针数组</p>
</li>
<li><p><em>C++ 中 数组名是一个指向数组中第一个元素的常量指针*</em><br>即：</p>
<blockquote>
<p>double balance[50];<br>balance是一个指向&amp;balance[0]的指针，即数组 balance 的第一个元素的地址<br>因此：*(balance + 4) 是一种访问 balance[4] 数据的合法方式</p>
</blockquote>
</li>
<li><p>4.C++指向指针的指针（多级间接寻址）<br>指向指针的指针，就是一个指针指向的地址保存的是另一个指针的地址，另一个指针保存的才是实际值的位置</p>
</li>
<li><figure class="image-box">
                <img src="test6.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>
<blockquote>
<p>int **var;//多级间接寻址</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">double i=3;</span><br><span class="line">double *p_i=&amp;i;</span><br><span class="line">double **pp_i=&amp;p_i;</span><br></pre></td></tr></table></figure>
<h4 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h4><p>引用 针对的是变量，这个要和 typedef 针对类型区分开来</p>
<p>可以在数据类型和变量名之间加上一个 &amp; 符号来声明一个引用，就像下面这样</p>
<blockquote>
<p>int a=8;<br>int &amp;b=a;//正确，需要区别等式的左值和右值<br>这里&amp;是在左值，不能看作是取地址符，而是声明引用的一种格式<br>&amp;出现在右值时才是取地址符</p>
</blockquote>
<p>不能直接指向数据<br>  int &amp;b=8；//错误<br>指针和引用的区别：<br>    1.引用必须在创建时被初始化。指针可以在任何时间被初始化<br>    int &b; // 错误<br>    2.不存在空引用。引用必须连接到一块合法的内存，也就是不能有如下的声明<br>    int &amp;c = NULL;   // 错误</p>
<h5 id="引用的使用"><a href="#引用的使用" class="headerlink" title="引用的使用"></a>引用的使用</h5><ul>
<li><p>引用作为参数<br>引用可以像指针一样作为函数的参数，使用方式和指针一模一样<br>相比传一般的参数更加的安全</p>
<blockquote>
<p>void swap(int &amp;a,int &amp;b){<br>   int temp=a;<br>   a=b;<br>   b=temp;<br>}</p>
</blockquote>
</li>
<li><p>引用作为返回值<br>函数也可以返回一个引用，方式与返回一个指针类似，通常的做法是使用引用替代指针</p>
<blockquote>
<p>double nums[]={11.11, 12.58, 12.21, 25.25, 88.8};<br>double&amp; setNum(int i){<br>   return nums[i];<br>}</p>
</blockquote>
</li>
</ul>
<p>当函数返回一个引用时，返回的是一个指向返回值的隐式指针<br>因此，我们可以把返回引用的函数作为左值，例如</p>
<blockquote>
<p>setNum(1)=203.0;</p>
</blockquote>
<p>例如实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">double nums[] = &#123;11.11, 12.58, 12.21, 25.25, 88.8&#125;;</span><br><span class="line"> double&amp; setNums(int i)&#123;</span><br><span class="line">	return nums[i]; 	</span><br><span class="line"> &#125;  </span><br><span class="line"> int main()&#123;</span><br><span class="line">	setNums(1)=203.0;//改变引用的值</span><br><span class="line">	std::cout&lt;&lt; setNums(1);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：203.0</p>
<p>** 注意事项 **<br>1.当返回一个引用时，被引用的对象不能超出作用域<br>返回一个对局部变量的引用是不合法的。<br>int&amp; func() {<br>   int q;<br>   return q;  // 在编译时发生错误<br>}</p>
<p>2.可以返回一个对静态变量的引用<br>int&amp; func() {<br>   static int x;<br>   return x;     // 安全，x 在函数作用域外依然是有效的<br>}</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><hr>
]]></content>
      
        <categories>
            
            <category> Computer-Science </category>
            
            <category> Programming Language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Programming Language </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Matlab相关]]></title>
      <url>/2019/11/05/Matlab_Learning/</url>
      <content type="html"><![CDATA[<h1 id="Matlab学习"><a href="#Matlab学习" class="headerlink" title="Matlab学习"></a>Matlab学习</h1><h3 id="1-dir-使用"><a href="#1-dir-使用" class="headerlink" title="1. dir()使用"></a>1. dir()使用</h3><p>dir函数可以有调用方式</p>
<ul>
<li><p>dir(‘.’) 列出当前目录下所有子文件夹和文件</p>
</li>
<li><p>dir(‘G:\Matlab’) 列出指定目录下所有子文件夹和文件</p>
</li>
<li><p>dir(‘*.m’) 列出当前目录下符合正则表达式的文件夹和文件</p>
</li>
<li><p>得到的为结构体数组每个元素都是如下形式的结构体</p>
<pre><code>name  -- filename
date  -- modification date
bytes  -- number of bytes allocated to the file
isdir  -- 1 if name is a directory and 0 if not
datenum -- modification date as a MATLAB serial date number</code></pre><p> 分别为文件名,修改日期,大小,是否为目录,Matlab特定的修改日期</p>
<p>可以提取出文件名以作读取和保存用.</p>
</li>
</ul>
<h3 id="2-exist-使用"><a href="#2-exist-使用" class="headerlink" title="2. exist()使用"></a>2. exist()使用</h3><ul>
<li>判断某个变量，函数，类，文件夹等参数是否存在。</li>
<li>A=exists(“name”,”kind”)，name可以是变量，函数，类，文件夹等</li>
<li>返回值的含义如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 不存在则返回值 </span><br><span class="line">1 name 可以是变量名，如果存在，返回值 </span><br><span class="line">2 函数名、m 文件名，存在则返回值 </span><br><span class="line">3 mex 文件、dll 文件，存在则返回值</span><br><span class="line">4 内嵌的函数，存在则返回值 5 p码文件 ， 存在则返回值 </span><br><span class="line">6 目录，存在则返回值 </span><br><span class="line">7 路径，存在则返回值 </span><br><span class="line">8 Java class，存在则返回值</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3. for循环"></a>3. for循环</h3><ul>
<li>for k=1:10  正序遍历</li>
<li>for k=10:-1:1 倒序遍历，从10到1，每次递减-1</li>
</ul>
<h3 id="4-strrep-使用"><a href="#4-strrep-使用" class="headerlink" title="4.strrep()使用"></a>4.strrep()使用</h3><ul>
<li>查找并替换函数</li>
<li>strrep(A,B,C); 在A中查找B并替换为C</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Computer-Science </category>
            
            <category> Programming Language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Programming Language </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VS使用及错误合集]]></title>
      <url>/2019/11/04/Basic_Software_Use_VS/</url>
      <content type="html"><![CDATA[<h1 id="1-错误合集"><a href="#1-错误合集" class="headerlink" title="1.错误合集"></a>1.错误合集</h1><hr>
<h3 id="1-1-ErrorLINK2019无法解析的外部符号-WinMain-16"><a href="#1-1-ErrorLINK2019无法解析的外部符号-WinMain-16" class="headerlink" title="1.1 .ErrorLINK2019无法解析的外部符号_WinMain@16"></a>1.1 .ErrorLINK2019无法解析的外部符号_WinMain@16</h3><ul>
<li>原因：无法找到适当的程序入口函数，其中Windows程序和控制台程序Console的入口程序不一致，应该在项目配置信息中选择适当预处理器以及链接器中合适的子系统。</li>
</ul>
<ul>
<li><figure class="image-box">
                <img src="VS1.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>
</li>
<li><p>解决：</p>
</li>
</ul>
<ul>
<li><figure class="image-box">
                <img src="VS2.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>


</li>
</ul>
<h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h1><hr>
<ul>
<li>Ctrl+Shift+B：生成解决方案，形成可执行文件。</li>
<li>生成可执行文件后有两种形式，其中一种是调试，一种是直接执行不调试</li>
<li>(F5或Alt+F5)在调试程序过程中，若遇到断点，会停止在断点处，等待继续运行的指令，当程序运行完毕后不会直接退出，而会暂停程序。</li>
<li>(Ctrl+F5)直接执行程序（不调试），完全忽略断点，程序运行完毕后直接结束程序。</li>
</ul>
<hr>
<h2 id="在VS2017中安装配置OpenGL教程："><a href="#在VS2017中安装配置OpenGL教程：" class="headerlink" title="在VS2017中安装配置OpenGL教程："></a>在VS2017中安装配置OpenGL教程：</h2><p><a href="http://www.cnblogs.com/flylinmu/p/7823019.html" target="_blank" rel="noopener">http://www.cnblogs.com/flylinmu/p/7823019.html</a></p>
<p>注意：</p>
<ul>
<li><p>（1）.在VS中对于项目进行属性配置时，右键点击解决方案中的项目名称，选择“属性配置”。</p>
</li>
<li><p>（2）.在VS2017中新建一个Windows控制台项目时，会自动生成一个pch.h文件，项目将其默认为预编译头文件，当项目较大时，可以在pch.h头文件中加入大量的宏定义，便于后期的维护更新，但是当项目较小时，可以在项目配置中，选择C/C++,将预编译头省略。</p>
</li>
<li><p>相关博客：<br><a href="http://www.blog.csdn.net/weixin_43074474/article/details/89520392" target="_blank" rel="noopener">http://www.blog.csdn.net/weixin_43074474/article/details/89520392</a></p>
</li>
</ul>
<hr>
<h2 id="VS快捷键"><a href="#VS快捷键" class="headerlink" title="VS快捷键"></a>VS快捷键</h2><ul>
<li>Alt+→：代码提示代码</li>
<li>注释代码：Ctrl+K选中后再C</li>
<li>取消注释代码：Ctrl+K选中后再U</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 开发工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Visual Studio </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开发工具推荐及相关使用]]></title>
      <url>/2019/11/04/Basic_Software_Use/</url>
      <content type="html"><![CDATA[<h1 id="开发工具及使用"><a href="#开发工具及使用" class="headerlink" title="开发工具及使用"></a>开发工具及使用</h1><p>+++</p>
<h3 id="1-listary"><a href="#1-listary" class="headerlink" title="1. listary"></a>1. listary</h3><ul>
<li>双击Ctrl全局搜索</li>
<li>在文件管理器中双击空白处进行列表呼出</li>
</ul>
<h3 id="2-cmd"><a href="#2-cmd" class="headerlink" title="2.cmd"></a>2.cmd</h3><ul>
<li>在当前文件目录的显示栏下输入 cmd ,即可在当前路径下打开命令行</li>
</ul>
<h3 id="3-stb-image简单图像库"><a href="#3-stb-image简单图像库" class="headerlink" title="3,stb_image简单图像库"></a>3,stb_image简单图像库</h3><ul>
<li><p>重点关注三个头文件</p>
</li>
<li><figure class="image-box">
                <img src="1570780034511.png.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>

</li>
</ul>
<h3 id="4-Windows-OS"><a href="#4-Windows-OS" class="headerlink" title="4.Windows OS"></a>4.Windows OS</h3><ul>
<li>Shift+F10:鼠标右键快捷键</li>
<li>Win+Ctrl+←/→：窗口切换，保命技巧</li>
</ul>
<h3 id="5-RenderDoc"><a href="#5-RenderDoc" class="headerlink" title="5.RenderDoc"></a>5.RenderDoc</h3><ul>
<li>可集成到VS或者Unity3D中</li>
</ul>
<h3 id="6-Typora"><a href="#6-Typora" class="headerlink" title="6. Typora"></a>6. Typora</h3><ul>
<li>Ctrl+/：源代码模式进入或者退出</li>
</ul>
<h3 id="7-Visual-Studio-Code"><a href="#7-Visual-Studio-Code" class="headerlink" title="7. Visual Studio Code"></a>7. Visual Studio Code</h3><ul>
<li>Ctrl+Shift+P:调出主命令框</li>
<li>Ctrl +K选中后，再按V：预览markdown效果</li>
</ul>
<h3 id="8-Scons"><a href="#8-Scons" class="headerlink" title="8. Scons"></a>8. Scons</h3><ul>
<li>基于python的软件构建工具</li>
</ul>
<h3 id="9-Python"><a href="#9-Python" class="headerlink" title="9.Python"></a>9.Python</h3><p>在同一计算机上同时配置两个不同版本的Python时，例如Python2.7以及Python3.6两个版本，可以在Python27文件夹下将python.exe文件更名为python27.exe，然后在用户环境变量下的Path下维护两个版本的Python地址，每个版本两个地址（一个Python文件夹地址，一个Script地址）</p>
]]></content>
      
        <categories>
            
            <category> 开发工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> Tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Basic Tips about CS or SE]]></title>
      <url>/2019/11/04/Tips/</url>
      <content type="html"><![CDATA[<h3 id="1-HDR（High-Dynamic-Range）"><a href="#1-HDR（High-Dynamic-Range）" class="headerlink" title="1. HDR（High Dynamic Range）"></a>1. HDR（High Dynamic Range）</h3><ul>
<li>相比普通的图像，可以提供更多的动态范围和图像细节，根据不同的曝光时间的LDR（Low Dynamic Range）图像，相对应每个曝光时间对应最佳细节的LDR图像来合成最终的HDR图像，能够更好的反映除真实环境中的视觉效果。<a id="more"></a></li>
<li><ul>
<li>简单来说，就是一张图片中尽可能的显示最亮和最暗的地方。</li>
</ul>
</li>
<li>通过将拍出的几张不同曝光的照片，将每张照片曝光正常的部分保留，合成一张，就得到了一条了一张HDR图像。</li>
</ul>
<h3 id="2-HDR合成"><a href="#2-HDR合成" class="headerlink" title="2. HDR合成"></a>2. HDR合成</h3><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><ul>
<li>Unity中对于动态物体，例如人物等，使用Light Probe对于间接光照进行处理，Light Probe（采样点）对环境进行采样（发生在预处理阶段），在运行阶段，渲染器从邻近的采样点中取值，并对点进行插值处理。</li>
</ul>
<h3 id="4-计算机图形学（Computer-Graphics）和计算机视觉-Computer-Version"><a href="#4-计算机图形学（Computer-Graphics）和计算机视觉-Computer-Version" class="headerlink" title="4. 计算机图形学（Computer Graphics）和计算机视觉(Computer Version)"></a>4. 计算机图形学（Computer Graphics）和计算机视觉(Computer Version)</h3><ul>
<li>计算机图形（Computer Graphics）和计算机视觉（Computer Vision）是一对孪生兄弟，二者互为逆过程。</li>
<li><ul>
<li>计算机图形是预先知道3D物体的形状、位置、材料构成，以及场景的灯光和相机，然后渲染出场景。</li>
</ul>
</li>
<li>计算机视觉是已知拍到的图像，从中推断出有哪些物体，它们由什么材料制成，以及它们的3D位置和方向。</li>
</ul>
<h3 id="5-Mitsuba"><a href="#5-Mitsuba" class="headerlink" title="5. Mitsuba"></a>5. Mitsuba</h3><ul>
<li>一个面向研究用的开源软件，基于PBRT(Physically based rendering technology) 根据几何光学的物理性质编程实现</li>
<li>性能：实现了大多数常见的渲染算法</li>
<li>鲁棒性（Robustness）:采用底层算法（underlying algorithm）</li>
<li>可扩展性：可以并行计算，用大型计算簇实现与优化加速</li>
<li>限制：对于光的波特性无法很好的表现</li>
<li>极其模块化，它由一小组核心库和100多种不同的插件组成，这些插件实现了从材料和光源到完整渲染算法的功能。</li>
<li>与其他开源渲染器相比，Mitsuba非常重视实验渲染技术，例如Metropolis LightTransport的路径配方和体积建模方法。 因此，对于那些想要尝试这种尚未进入主流渲染器的技术的人来说，它可能是真正感兴趣的，它也为这一领域的研究提供了坚实的基础。</li>
</ul>
<h3 id="6-Tips"><a href="#6-Tips" class="headerlink" title="6.Tips"></a>6.Tips</h3><ul>
<li><p>jpg不支持透明度，有损压缩的图像格式，有损压缩会使得原始图片数据质量下降，也使得其占用空间小，在网页应用中加速速度快。</p>
</li>
<li><p>png支持透明度，无视压缩的图像格式，能在保证不失真的情况下尽可能压缩图像文件的大小，因此图像质量高，在一些贴纸应用中大多采用png图片。</p>
</li>
<li><p>Markdown：一种使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使得普通文本具有一定的格式。<br>Markdown具有一系列的衍生版本，用于扩展Markdown功能（例如：表格，脚注，内嵌HTML等）</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Computer-Science </category>
            
            <category> Basic Tips </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello Graphic World]]></title>
      <url>/2019/11/04/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="创建新的分页"><a href="#创建新的分页" class="headerlink" title="创建新的分页"></a>创建新的分页</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page XXX</span><br></pre></td></tr></table></figure>
<h3 id="创建新的博文"><a href="#创建新的博文" class="headerlink" title="创建新的博文"></a>创建新的博文</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new XXX</span><br></pre></td></tr></table></figure>

<ul>
<li>使用图像资源的相对路径的话，需要在yml文件中设置，并且在_posts文件中创建一个与博文名称一致的文件夹，并将图像资源放置其中。</li>
</ul>
]]></content>
      
        
    </entry>
    
  
  
</search>
