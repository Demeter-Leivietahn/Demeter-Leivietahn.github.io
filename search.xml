<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[PBRT（Chapter1）]]></title>
      <url>/2019/11/05/PBRT_Learning_1/</url>
      <content type="html"><![CDATA[<h1 id="PBRT-CHAPTER-1"><a href="#PBRT-CHAPTER-1" class="headerlink" title="PBRT CHAPTER_1"></a>PBRT CHAPTER_1</h1><p>*Introduction<br>PBRT(Physically Based Rendering Toolkit)<br>基于物理渲染</p>
<p>渲染是根据三维场景的描述生成图像的过程。显然，这是一个非常广泛的任务，有许多方法可以实现它。基于物理的技术试图模拟现实;也就是说，他们使用物理原理来模拟光和物质的相互作用。虽然基于物理的方法似乎是处理呈现的最明显的方法，但它只是在过去10年左右的实践中才被广泛采用。<br>学习基于PBRT-v3<br>友情链接：<br>（一）PBRT-v3在线电子书：<a href="http://www.pbr-book.org/3ed-2018/contents.html" target="_blank" rel="noopener">http://www.pbr-book.org/3ed-2018/contents.html</a><br>（二）实验室学长的PBRT-v3配置教程: <a href="https://fancyvin.github.io/2019/07/13/how-to-compile-pbrt-v3-renderer/" target="_blank" rel="noopener">https://fancyvin.github.io/2019/07/13/how-to-compile-pbrt-v3-renderer/</a></p>
<h2 id="1-1-Literate-Programming-文学编程"><a href="#1-1-Literate-Programming-文学编程" class="headerlink" title="1.1 Literate Programming 文学编程"></a>1.1 Literate Programming 文学编程</h2><p>PBRT-v2和-v3之间的改动</p>
<ul>
<li>增加了一个功能完备的BRDF模型，支持体积光照与重要性多重路径采样。</li>
<li>次表面散射，基于光线追踪技术，无需预处理。</li>
<li>解决浮点数四折五入的问题</li>
<li>光子映射</li>
<li>样本生成</li>
</ul>
<h2 id="1-2-Photorealistic-Rendering-and-the-Ray-Tracing-Algorithm-照片级渲染及光线跟踪算法"><a href="#1-2-Photorealistic-Rendering-and-the-Ray-Tracing-Algorithm-照片级渲染及光线跟踪算法" class="headerlink" title="1.2 Photorealistic Rendering and the Ray-Tracing Algorithm 照片级渲染及光线跟踪算法"></a>1.2 Photorealistic Rendering and the Ray-Tracing Algorithm 照片级渲染及光线跟踪算法</h2><ul>
<li>渲染分块问题：<br>渲染任务过多的分块会影响性能。<br>过小分块也是不科学的，因为处理核心问题有一定的开销。<br>场景的复杂性会对不同CPU核心的渲染速度产生影响。所以如果是分块数等于核心数，渲染完的核心会等待没渲染完的核心。</li>
</ul>
<p>PBRT采用的是16*16的方案</p>
<p>浮点类型<br>pbrt采用了FLOAT，这样浮点格式会根据宏进行调整</p>
<h3 id="1-2-1-Camera相机"><a href="#1-2-1-Camera相机" class="headerlink" title="1.2.1 Camera相机"></a>1.2.1 Camera相机</h3><ul>
<li>针孔相机<br>  胶片Film    针孔Pinhole   视见体Viewing Volume<h3 id="1-2-2-Ray-Object-Intersection光线-对象相交"><a href="#1-2-2-Ray-Object-Intersection光线-对象相交" class="headerlink" title="1.2.2 Ray-Object Intersection光线-对象相交"></a>1.2.2 Ray-Object Intersection光线-对象相交</h3></li>
<li>当相机生成一条光线时，renderer的首要任务是：确定与光线intersect的首个对象和相交的位置。This intersection point is the visible point along the ray, and we will want to simulate the intersection of light with the object at this point. </li>
</ul>
<figure class="image-box">
                <img src="1.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>

<p> 给定光线r,o为光线源点，d表示方向向量，参数t的范围为0到无穷，通过t取不同的值可以得到光线上的任何一点。<br> 在交点的计算中，需测试光线与全部场景对象之间的相交结果，并选取与光线首次相交的对象。<br> 多数场景均由多个对象构成，蛮力进行相机计算将依次测试场景中的各个对象，并选取相交结果最小的t值，但这种方案的计算速度较为缓慢；还可以引入加速结构，并剔除一组对象，进行算法的加速。</p>
<h3 id="1-2-3-Light-Distribution光照分布"><a href="#1-2-3-Light-Distribution光照分布" class="headerlink" title="1.2.3 Light Distribution光照分布"></a>1.2.3 Light Distribution光照分布</h3><figure class="image-box">
                <img src="2.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>
<ul>
<li>较大球体上某点处的能量将小于较小球体，其原因在于相同的光能分布于较大的面积上，特别的，对于半径为r的球体，其表面某点处的能量与1/r^2成比例。</li>
<li>由于点光源采用各向均等方式辐射能量。因而两球体存储相同光能。</li>
<li>对于球体表面面积微分dA,其上的光能能够表示为：<figure class="image-box">
                <img src="3.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure><br>其中Φ表示光源能量，θ为表面点法线与表面点和光源连线的夹角<figure class="image-box">
                <img src="4.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>


</li>
</ul>
<h3 id="1-2-4Visibility-可见性"><a href="#1-2-4Visibility-可见性" class="headerlink" title="1.2.4Visibility 可见性"></a>1.2.4Visibility 可见性</h3><ul>
<li>确定是否被遮挡（阴影）</li>
<li>当着色点与光源之间没有遮挡时，着色点方可被“点亮”<br>确定是否被遮挡：</li>
<li>1、着色点与光源之间的连线，指向光源——阴影光线（shaow rays）</li>
<li>2、通过交点计算，算出参数t,确定阴影光线的交点，并通过t的值，确定遮挡关系</li>
</ul>
<h3 id="1-2-5表面散射-Surface-Scattering"><a href="#1-2-5表面散射-Surface-Scattering" class="headerlink" title="1.2.5表面散射 Surface Scattering"></a>1.2.5表面散射 Surface Scattering</h3><p>场景中的各对象的材质属性，描述了表面各点处的外观属性，材质通过BRDF定义（双向反射分布函数），而材质决定外观（BSDF决定通用散射行为）</p>
<figure class="image-box">
                <img src="5.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>


<p>参数含义：</p>
<figure class="image-box">
                <img src="6.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>    
<h3 id="1-2-6-Indirect-Light-Transport"><a href="#1-2-6-Indirect-Light-Transport" class="headerlink" title="1.2.6 Indirect Light Transport"></a>1.2.6 Indirect Light Transport</h3><figure class="image-box">
                <img src="7.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>
<h3 id="1-2-7-Ray-Propagation-射线传播"><a href="#1-2-7-Ray-Propagation-射线传播" class="headerlink" title="1.2.7 Ray Propagation 射线传播"></a>1.2.7 Ray Propagation 射线传播</h3><p>渲染环境不一定是真空（vacuum）<br>参与介质介质影响光线传播<br>影响的两种方式：<br>（一）介质在不同的方向上吸收或散射，衰减光线<br>（二）如：介质自发光或者价值沿当前光线相反方向并向其他方向散射光线</p>
<h2 id="1-3-pbrt-System-Overview-系统总览"><a href="#1-3-pbrt-System-Overview-系统总览" class="headerlink" title="1.3 pbrt:System Overview 系统总览"></a>1.3 pbrt:System Overview 系统总览</h2><p>标准的面向对象构建<br>抽象类针对重要实体进行定义<br>The majority of the system is implemented purely in terms of the interface provided by these abstract base class.(系统的主要内容根据抽象类提供的接口实现)</p>
<figure class="image-box">
                <img src="1573095588456.png" alt="[sorry,图片挂了]" title="[pbrt-v3中的10个抽象类]" class="[samll]">
                <p>[pbrt-v3中的10个抽象类]</p>
            </figure>


<p>pbrt网站中有源码以及额外实现的图形、材质等内容的源码</p>
<h3 id="1-3-1-Phase-of-Execution执行阶段"><a href="#1-3-1-Phase-of-Execution执行阶段" class="headerlink" title="1.3.1 Phase of Execution执行阶段"></a>1.3.1 Phase of Execution执行阶段</h3><p>PBRT程序执行：<br>① 解析用户提供的.pbrt文件（场景描述文件）<br>初始化相应的类→Scene类的实例和Integrator类（此类用于实现算法渲染Scene）的实例<br>② 整个渲染流程</p>
<figure class="image-box">
                <img src="1573096051239.png" alt="[sorry,图片挂了]" title="[pbrt-v3中的10个抽象类]" class="[samll]">
                <p>[pbrt-v3中的10个抽象类]</p>
            </figure>


<ul>
<li>并行相关问题<br>① 读取场景文件以及创建场景都是单线程的，获取场景信息因为不涉及到修改数据，所以可以无视。我们只需要关注修改内存数据的情况。<br>② 请不要在不同步的情况下修改数据<br>③ 对应初始化可以考虑std::call_once函数<br>④ 实用程序类MemoryArena（用于高性能临时内存分配）和RNG（伪随机数生成）也不适合多线程使用; 这些类存储在调用其方法时被修改的状态，并且相互排除的保护修改到其状态的开销相对于它们执行的计算量而言过多。 因此，在上面的SamplerIntegrator :: Render()方法的代码中，实现在堆栈上分配这些类的perthread实例。<br>⑤ 每个线程需要各复制一个Sampler的实例，以保证线程安全<br>⑥ 目前的计算机架构运算除法、平方根和三角函数是最慢的。加法与乘法相比之下要快10~50倍。所以我们可以减少这种数学运算数量来提高性能。例如我们可以提前计算1/v,之后再乘。而不是重复除以v。</li>
</ul>
<h3 id="1-3-2-Scene-Representation-场景表达"><a href="#1-3-2-Scene-Representation-场景表达" class="headerlink" title="1.3.2 Scene Representation 场景表达"></a>1.3.2 Scene Representation 场景表达</h3><ul>
<li><p>PBRT中的main函数→处理argv中提供的命令行参数<br>  → 初始化Option Structure,传给pbrtInit()进行系统内的初始化<br>  → parse（解析）Scene ,创建 Scene、Integrator对象<br>  after rendering→pbrtClaenup()，在系统退出前进行清理</p>
</li>
<li><p>ParseFile()  解析Scene</p>
</li>
<li><p>Light对象：场景中的光源，指定光的形状和能量分布<br>  场景使用C++标准库（std）的shared_ptr实例向量，存储所有灯光<br>  pbrt使用共享指针跟踪对象被其他实例引用的次数（当最后一个持有实例的引用被销毁时，引用次数为零）<br>  系统中很多部分需要访问光源，因此Scene使其成为公共变量。</p>
</li>
<li><p>场景定义后，渲染开始前，进行预处理 Preprocess()</p>
</li>
<li><p>Scene提供两个光线图元求交函数：<br>①bool Intersect(const Ray&amp;ray,SurfaceInteraction *insect)const<br>对指定光线进行求交判定，将沿光线与图元相交最近的交点信息保存到SurfaceIntersection结构中<br>②bool IntersectP(const Ray&amp;ray)const<br>仅确定沿光线是否存在交点</p>
</li>
</ul>
<h3 id="1-3-3-Integrator-Interface-and-SamplerIntegrator"><a href="#1-3-3-Integrator-Interface-and-SamplerIntegrator" class="headerlink" title="1.3.3 Integrator Interface and SamplerIntegrator"></a>1.3.3 Integrator Interface and SamplerIntegrator</h3><ul>
<li><p>渲染场景是由实现了Integrator接口的实例完成的，这其中Integrator是一个抽象基类，提供Render()方法<br>virtual void Render(const Scene &amp;scene)=0;<br>Integrator接口定义在：core/integrator.h中<br>Integrator实用方法定义在：core/integrator.cpp中<br>各类积分器的实现位于Integrator文件目录中</p>
</li>
<li><p>Integrator<br> ↓继承<br>SamplerIntegrator (Create in RenderOptions::MakeIntegrator)<br> ↓实现<br>WhittedIntegrator</p>
</li>
</ul>
<p>在SamplerIntegrator中，存储了指向Sampler的指针</p>
<ul>
<li>Camera对象：控制相机相关，postion,orientation,filed of view ,focus等</li>
<li>Film对象：在Camera对象内，控制图像存储</li>
</ul>
<h3 id="1-3-4-The-Main-Rendering-Loop"><a href="#1-3-4-The-Main-Rendering-Loop" class="headerlink" title="1.3.4 The Main Rendering Loop"></a>1.3.4 The Main Rendering Loop</h3><ul>
<li>当Scene、Integrator被指定后，Invoke(调用)Render()开启main rendering loop</li>
</ul>
<p>实现：at each of a series of positions on the image plane, the method uses the Camera and the Sampler to generate a ray into the scene and then uses the Li() method to determine the amount of light arriving at the image plane along that ray. This value is passed to the Film, which records the light’s contribution.</p>
<p>主循环源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">void SamplerIntegrator::Render(const Scene &amp;scene) &#123;</span><br><span class="line">    Preprocess(scene, *sampler);//预处理</span><br><span class="line">    //分块并行渲染图片</span><br><span class="line"></span><br><span class="line">    //计算tiles, _nTiles_,用于并行运算</span><br><span class="line">    Bounds2i sampleBounds = camera-&gt;film-&gt;GetSampleBounds();</span><br><span class="line">    Vector2i sampleExtent = sampleBounds.Diagonal();</span><br><span class="line">    //书中说16*16分块可以解决大部分情况</span><br><span class="line">    const int tileSize = 16;</span><br><span class="line">    //sampleExtent.x + tileSize - 1 整除考虑</span><br><span class="line">    Point2i nTiles((sampleExtent.x + tileSize - 1) / tileSize,</span><br><span class="line">                   (sampleExtent.y + tileSize - 1) / tileSize);</span><br><span class="line">    ProgressReporter reporter(nTiles.x * nTiles.y, &quot;Rendering&quot;);</span><br><span class="line">    &#123;</span><br><span class="line">        ParallelFor2D([&amp;](Point2i tile) &#123;</span><br><span class="line">            // Render section of image corresponding to _tile_</span><br><span class="line"></span><br><span class="line">            //内存池，之后会给Li函数</span><br><span class="line">            MemoryArena arena;</span><br><span class="line"></span><br><span class="line">            //给每个块分配一个Samper实例</span><br><span class="line">            int seed = tile.y * nTiles.x + tile.x;</span><br><span class="line">            std::unique_ptr&lt;Sampler&gt; tileSampler = sampler-&gt;Clone(seed);</span><br><span class="line"></span><br><span class="line">            //计算块的采样边界</span><br><span class="line">            int x0 = sampleBounds.pMin.x + tile.x * tileSize;</span><br><span class="line">            int x1 = std::min(x0 + tileSize, sampleBounds.pMax.x);</span><br><span class="line">            int y0 = sampleBounds.pMin.y + tile.y * tileSize;</span><br><span class="line">            int y1 = std::min(y0 + tileSize, sampleBounds.pMax.y);</span><br><span class="line">            Bounds2i tileBounds(Point2i(x0, y0), Point2i(x1, y1));</span><br><span class="line">            LOG(INFO) &lt;&lt; &quot;Starting image tile &quot; &lt;&lt; tileBounds;</span><br><span class="line"></span><br><span class="line">            //取得指定范围的图片块</span><br><span class="line">            std::unique_ptr&lt;FilmTile&gt; filmTile =</span><br><span class="line">                camera-&gt;film-&gt;GetFilmTile(tileBounds);</span><br><span class="line"></span><br><span class="line">            //开始指定区域的渲染循环</span><br><span class="line">            for (Point2i pixel : tileBounds) &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    ProfilePhase pp(Prof::StartPixel);</span><br><span class="line">                    tileSampler-&gt;StartPixel(pixel);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Do this check after the StartPixel() call; this keeps</span><br><span class="line">                // the usage of RNG values from (most) Samplers that use</span><br><span class="line">                // RNGs consistent, which improves reproducability /</span><br><span class="line">                // debugging.</span><br><span class="line">                if (!InsideExclusive(pixel, pixelBounds))</span><br><span class="line">                    continue;</span><br><span class="line"></span><br><span class="line">                do &#123;</span><br><span class="line">                    //初始化相机采样，存储了时间以及镜头位置的采样值</span><br><span class="line">                    CameraSample cameraSample =</span><br><span class="line">                        tileSampler-&gt;GetCameraSample(pixel);</span><br><span class="line"></span><br><span class="line">                    //生成相机光线</span><br><span class="line">                    //以及光线的pdf</span><br><span class="line">                    RayDifferential ray;</span><br><span class="line">                    Float rayWeight =</span><br><span class="line">                        camera-&gt;GenerateRayDifferential(cameraSample, &amp;ray);</span><br><span class="line">                    ray.ScaleDifferentials(</span><br><span class="line">                        1 / std::sqrt((Float)tileSampler-&gt;samplesPerPixel));</span><br><span class="line">                    ++nCameraRays;</span><br><span class="line"></span><br><span class="line">                    //估算当前相机光线辐射度</span><br><span class="line">                    Spectrum L(0.f);</span><br><span class="line">                    if (rayWeight &gt; 0) L = Li(ray, scene, *tileSampler, arena);</span><br><span class="line"></span><br><span class="line">                    //对渲染出错误结果的处理，log相应信息</span><br><span class="line">                    if (L.HasNaNs()) &#123;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; StringPrintf(</span><br><span class="line">                            &quot;Not-a-number radiance value returned &quot;</span><br><span class="line">                            &quot;for pixel (%d, %d), sample %d. Setting to black.&quot;,</span><br><span class="line">                            pixel.x, pixel.y,</span><br><span class="line">                            (int)tileSampler-&gt;CurrentSampleNumber());</span><br><span class="line">                        L = Spectrum(0.f);</span><br><span class="line">                    &#125; else if (L.y() &lt; -1e-5) &#123;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; StringPrintf(</span><br><span class="line">                            &quot;Negative luminance value, %f, returned &quot;</span><br><span class="line">                            &quot;for pixel (%d, %d), sample %d. Setting to black.&quot;,</span><br><span class="line">                            L.y(), pixel.x, pixel.y,</span><br><span class="line">                            (int)tileSampler-&gt;CurrentSampleNumber());</span><br><span class="line">                        L = Spectrum(0.f);</span><br><span class="line">                    &#125; else if (std::isinf(L.y())) &#123;</span><br><span class="line">                          LOG(ERROR) &lt;&lt; StringPrintf(</span><br><span class="line">                            &quot;Infinite luminance value returned &quot;</span><br><span class="line">                            &quot;for pixel (%d, %d), sample %d. Setting to black.&quot;,</span><br><span class="line">                            pixel.x, pixel.y,</span><br><span class="line">                            (int)tileSampler-&gt;CurrentSampleNumber());</span><br><span class="line">                        L = Spectrum(0.f);</span><br><span class="line">                    &#125;</span><br><span class="line">                    VLOG(1) &lt;&lt; &quot;Camera sample: &quot; &lt;&lt; cameraSample &lt;&lt; &quot; -&gt; ray: &quot; &lt;&lt;</span><br><span class="line">                        ray &lt;&lt; &quot; -&gt; L = &quot; &lt;&lt; L;</span><br><span class="line"></span><br><span class="line">                    // Add camera ray&apos;s contribution to image</span><br><span class="line">                    filmTile-&gt;AddSample(cameraSample.pFilm, L, rayWeight);</span><br><span class="line"></span><br><span class="line">                   //释放内存池</span><br><span class="line">                    arena.Reset();</span><br><span class="line">                &#125; while (tileSampler-&gt;StartNextSample());</span><br><span class="line">            &#125;</span><br><span class="line">            LOG(INFO) &lt;&lt; &quot;Finished image tile &quot; &lt;&lt; tileBounds;</span><br><span class="line"></span><br><span class="line">            //将图片块合并到图片上去</span><br><span class="line">            camera-&gt;film-&gt;MergeFilmTile(std::move(filmTile));</span><br><span class="line">            reporter.Update();</span><br><span class="line">        &#125;, nTiles);</span><br><span class="line">        reporter.Done();</span><br><span class="line">    &#125;</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;Rendering finished&quot;;</span><br><span class="line"></span><br><span class="line">    //保存图片到文件</span><br><span class="line">    camera-&gt;film-&gt;WriteImage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-5-An-Integrator-for-Whitted-Ray-Tracing"><a href="#1-3-5-An-Integrator-for-Whitted-Ray-Tracing" class="headerlink" title="1.3.5 An Integrator for Whitted Ray Tracing"></a>1.3.5 An Integrator for Whitted Ray Tracing</h3><ul>
<li></li>
</ul>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=501468332&auto=1&height=32"></iframe>
]]></content>
      
        <categories>
            
            <category> Computer-Science </category>
            
            <category> RayTracing </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RayTracing </tag>
            
            <tag> PBRT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[全局光照（总览）]]></title>
      <url>/2019/11/05/GI_1/</url>
      <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul>
<li>全局光照，(Global Illumination,简称 GI), 或被称为Indirect Illumination, 间接光照，是指既考虑场景中直接来自光源的光照（Direct Light）又考虑经过场景中其他物体反射后的光照（Indirect Light）的一种渲染技术。使用全局光照能够有效地增强场景的真实感。</li>
</ul>
<p>即可以理解为：全局光照 = 直接光照(Direct Light) + 间接光照(Indirect Light)<br>下面是直接光照和全局光照的对比</p>
<p>@column-2{</p>
<p>@card{</p>
<figure class="image-box">
                <img src="1.jpg" alt="[sorry,图片挂了]" title="[直接光照]" class="justify-small">
                <p>[直接光照]</p>
            </figure>

<p>}</p>
<p>@card{</p>
<figure class="image-box">
                <img src="2.jpg" alt="[sorry,图片挂了]" title="[全局光照]" class="justify-small">
                <p>[全局光照]</p>
            </figure>

<p>}</p>
<p>}</p>
<p><strong>全局光照技术历程</strong></p>
<ul>
<li><p>光线投射 Ray Casting<br>其具体思路是从每一个像素射出一条射线，然后找到最接近的物体挡住射线的路径，而视平面上每个像素的颜色取决于从可见光表面产生的亮度。</p>
</li>
<li><p>光线追踪 Ray Tracing<br>Turner Whitted在光线投射的基础上，加入光与物体表面的交互，让光线在物体表面沿着反射，折射以及散射方式上继续传播，直到与光源相交。<br>这一方法后来也被称为经典光线跟踪方法、递归式光线追踪（Recursive Ray Tracing）方法，或 Whitted-style 光线跟踪方法。</p>
</li>
<li><p>分布式光线追踪 Distributed Ray Tracing<br>Cook于1984年引入蒙特卡洛方法（Monte Carlo method）到光线跟踪领域，将经典的光线跟踪方法扩展为分布式光线跟踪算法，又称为随机光线追踪。<br>可以模拟更多的效果，如金属光泽、软阴影、景深（ Depthof Field）、运动模糊等等。</p>
</li>
<li><p>渲染方程 The Rendering Equation<br>Kajiya于1986年建立了渲染方程的相关理论，使用它来解释光能传输的产生的各种现象。这一方程描述了场景中光能传输达到稳定状态以后，物体表面某个点在某个方向上的辐射率（Radiance）与入射辐射亮度等的关系。<br>可以将渲染方程理解为全局光照算法的基础，随后出现的很多全局光照的算法，都是以渲染方程为基础，对其进行简化的求解，以达到优化性能的目的。渲染方程根据光的物理学原理，以及能量守恒定律，完美地描述了光能在场景中的传播。很多真实感渲染技术都是对它的一个近似。</p>
</li>
<li><p>路径追踪 Path Tracing<br>根据渲染方程， Kajiya 提出的路径追踪方法是第一个无偏（Unbiased）的渲染方法。<br>路径追踪的基本思想是从视点发出一条光线，光线与物体表面相交时根据表面的材质属性继续采样一个方向，发出另一条光线，如此迭代，直到光线打到光源上（或逃逸出场景），然后用蒙特卡洛的方法，计算其贡献，作为像素的颜色值。而使用蒙特卡洛方法对积分的求解是无偏的，只要时间足够长，最终图像能收敛到一个正确的结果。</p>
</li>
<li><p>双向路径追踪 Bidirectional Path Tracing<br>基本思想是同时从视点、光源打出射线，经过若干次反弹后，将视点子路径（ eye path） 和光源子路径（ light path） 上的顶点连接起来（连接时需要测试可见性），以快速产生很多路径。<br>这种方法能够产生一些传统路径追踪难以采样到的光路，所以能够很有效地降低噪声。<br>进一步的， [Veach 1997]将渲染方程改写成对路径积分的形式，允许多种路径采样的方法来求解该积分。</p>
</li>
<li><p>梅特波利斯光照传输 Metropolis Light Transport 简称MLT<br>路径追踪（ Path Tracing）中一个核心问题就是怎样去尽可能多的采样一些贡献大的路径，而该方法可以自适应的生成贡献大的路径，简单来说它会避开贡献小的路径，而在贡献大的路径附近做更多局部的探索，通过特殊的变异方法，生成一些新的路径，这些局部的路径的贡献往往也很高。<br>与双向路径追踪相比， MLT 更加鲁棒，能处理各种复杂的场景。<br>比如说整个场景只通过门缝透进来的间接光照亮，此时传统的路径追踪方法因为难以采样到透过门缝的这样的特殊路径而产生非常大的噪声。</p>
</li>
</ul>
<p><strong>回到光线追踪（Ray Tracing）上:</strong><br>上面我们说到Ray Tracing是三维计算机图形学中的特殊渲染方法，跟踪从眼睛发出的光线而不是光源发出的光线。<br>通过这样一项技术得到的结果有着更好的光线效果，例如对于反射和折射有着更准确的模拟效果，并且效率非常高，追求高质量图像时常采用这样的方式。<br>Ray Tracing的缺点就是性能，它所需要的计算量非常巨大。<br>传统的RayTracing并不一定是真实效果图像，只有在非常近似或者完全实现渲染方程时，才能实现真正的真实效果图像。由于渲染方程描述了每个光束的物理效果，所以实现渲染方程可以得到真正的真实效果，但是，考虑到所需要的计算资源，这通常是无法实现的。于是，所有可以实现的渲染模型都必须是渲染方程的近似，而光线跟踪就不一定是最为可行的方法。包括光子映射在内的一些方法，都是依据光线跟踪实现一部分算法，但是可以得到更好的效果。</p>
<p><strong>再讲到路径追踪（Path Tracing）上：</strong><br>简单来说，路径追踪 = 光线追踪+ 蒙特卡洛方法。</p>
<p><strong>我们再来总结一下Ray Casting，Ray Tracing，PathTracing这三者的区别</strong></p>
<ul>
<li>Ray Casting：其它就是ray tracing的第一步，发射光线，与物体相交。</li>
<li>Ray Tracing：这其实是个框架，而不是个方法。符合这个框架的都叫raytracing。这个框架就是从视点发射ray，与物体相交就根据规则反射、折射或吸收。遇到光源或者走太远就停住。一般来说运算量不小。</li>
<li>Path Tracing：是ray tracing + 蒙特卡洛法。在相交后会选一个随机方向继续跟踪，并根据BRDF计算颜色。运算量也不小。还有一些小分类，比如Bidirectional path tracing。</li>
</ul>
<p><strong>最后我们来学习一下AO</strong><br>AO是Ambient Occlusion的简称，是全局光照明的一种近似替代品，<br>可以产生重要的视觉明暗效果，通过描绘物体之间由于遮挡而产生的阴影， 能够更好地捕捉到场景中的细节，可以解决漏光，阴影漂浮等问题，改善场景中角落、锯齿、裂缝等细小物体阴影不清。<br>AO最常用的方法是SSAO，UE4中的AO即是采用这种方案</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1308281829&auto=1&height=66"></iframe>
]]></content>
      
        <categories>
            
            <category> Computer-Science </category>
            
            <category> RayTracing </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RayTracing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RayTracing In One Weekend（一）]]></title>
      <url>/2019/11/05/RayTracing_OneWeekend_1/</url>
      <content type="html"><![CDATA[<h1 id="vec3类解读"><a href="#vec3类解读" class="headerlink" title="vec3类解读"></a>vec3类解读</h1><h2 id="类体内"><a href="#类体内" class="headerlink" title="类体内"></a>类体内</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline float x()const&#123;</span><br><span class="line">return e[0]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类体内的函数x()</p>
<ul>
<li>const:表示该函数不修改类对象。</li>
<li>inline:表示该函数在程序中每个调用点上被内联展开。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline const vec3&amp; opearator+()const&#123;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类体内定义成员函数operator+()。</p>
<ul>
<li>operator+()：操作符重载。</li>
<li>&amp;：表示函数返回的是引用类型，此处表示返回的是一个vec3对象的引用。</li>
<li>const（左边这个）：表示函数返回不可被修改，此处表示返回的vec3对象的引用不可被修改。</li>
<li>const（右边这个）：表示该函数不修改类对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline vec3&amp; operator+=(const vec3&amp;v2);</span><br></pre></td></tr></table></figure>
<p>类体内声明成员函数operator+=()。</p>
<ul>
<li>&amp;（左边这个）：函数返回引用类型。当函数返回引用类型时，没有复制返回值。相反，返回的是对象本身。</li>
<li>&amp;（右边这个）：形参是引用类型。当把参数声明为引用时，传递的是形参本身。此时不需要将形参的值拷贝（赋值）给实参，可以直接操纵形参。和指针类似。</li>
</ul>
<h2 id="类体外："><a href="#类体外：" class="headerlink" title="类体外："></a>类体外：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline const vec3&amp; opearator+=(const vec3 &amp;v)&#123;</span><br><span class="line">	e[0]=v.e[0];</span><br><span class="line">	e[1]=v.e[1];</span><br><span class="line">	e[2]=v.e[2];</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类体外定义operator+=函数</p>
<ul>
<li>vec3::：表示类体外定义的operator+=()是vec3类的成员函数。“::”是域解析操作符。表示某个成员属于某个类，某个类的某个成员。</li>
<li>this：指向被调用对象的指针。</li>
<li>*this：由于函数定义的函数返回是引用类型，即返回的不是值或者指针，而是对象本身。所以，此处需要return *this来返回对象本身，而不是return this（返回的是指针）。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Computer-Science </category>
            
            <category> RayTracing </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RayTracing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++学习（二）]]></title>
      <url>/2019/11/05/C++_Learning_2/</url>
      <content type="html"><![CDATA[<p>参考资料：CSDN 图形跟班 相关博客</p>
<h1 id="C-重载操作符operator"><a href="#C-重载操作符operator" class="headerlink" title="C++重载操作符operator"></a>C++重载操作符operator</h1><h2 id="what："><a href="#what：" class="headerlink" title="what："></a>what：</h2><p>C++中的一个关键字，和运算符（例如=）一起使用，表示一个运算符重载函数，使扩展后的运算符的使用方法与重载前一致。</p>
<h2 id="why"><a href="#why" class="headerlink" title="why:"></a>why:</h2><p>C++提供的所有运算符只能支持对于基本数据类型以及标准库中提供的类的操作，而对于用户自己定义的类，如果想要通过操作符进行一些基本操作（比如：大小比较，相等判断等），需要用户自己定义操作符的具体实现。</p>
<h2 id="how-两种方式："><a href="#how-两种方式：" class="headerlink" title="how:两种方式："></a>how:两种方式：</h2><h3 id="将操作符重载实现为类的成员函数"><a href="#将操作符重载实现为类的成员函数" class="headerlink" title="将操作符重载实现为类的成员函数"></a>将操作符重载实现为类的成员函数</h3><p><strong>在类体中声明需要重载的操作符时，声明方式跟普通的成员函数一样</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//类结构中被声明的函数</span><br><span class="line"> bool operator==(const person&amp; ps) //person为自己定义的类</span><br><span class="line"> ｛</span><br><span class="line"> 		If（this-&gt;age == ps.age）&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line"> ｝</span><br></pre></td></tr></table></figure>
<h3 id="将操作符重载为非类的成员函数（即：全局函数）"><a href="#将操作符重载为非类的成员函数（即：全局函数）" class="headerlink" title="将操作符重载为非类的成员函数（即：全局函数）"></a>将操作符重载为非类的成员函数（即：全局函数）</h3><p>** 对于全局重载操作符，代表左操作数的参数必须被显式指定  **<br>即必须指明A==B中A的取值，而不能直接使用this关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//全局函数</span><br><span class="line">bool operator==(person const &amp; p1,person const &amp; p2);</span><br><span class="line">&#123;</span><br><span class="line">	if(p1.age==p2.age)&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>‘ 其中person的定义如下：’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class person&#123;</span><br><span class="line">	public :</span><br><span class="line">		int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="C-中修饰符-inline-表示内联函数"><a href="#C-中修饰符-inline-表示内联函数" class="headerlink" title="C++中修饰符 inline,表示内联函数"></a>C++中修饰符 inline,表示内联函数</h1><h2 id="what"><a href="#what" class="headerlink" title="what:"></a>what:</h2><p>修饰为内联函数</p>
<h2 id="why-1"><a href="#why-1" class="headerlink" title="why:"></a>why:</h2><p>为了解决<strong>频繁调用</strong>的小函数大量消耗栈空间的问题<br>（栈空间：放置程序的局部数据的内存空间）<br>避免频繁调用函数对栈空间重复开辟所带来的消耗</p>
<h2 id="how"><a href="#how" class="headerlink" title="how:"></a>how:</h2><ul>
<li><figure class="image-box">
                <img src="wps1.jpg" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>

</li>
</ul>
<p>inline使用限制：inline修饰的函数只适合于函数内部简单，没有包含复杂的逻辑结构，例如：while,switch，同时inline修饰的函数还不能自己调用自己。 </p>
<p>建议inline函数的定义放置于头文件中</p>
<p>定义在类中的函数都是默认内联的，如果需要将类中的方法写于类结构之外，而又想为内联函数，则需要显式声明为inline</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//定义于类结构之内的函数默认为内联函数</span><br><span class="line">void Foo(int x,int y)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果需要定义于类结构之外的内联函数</span><br><span class="line">inline void  A::Foo(int x,int y)&#123;&#125;</span><br><span class="line">//同时需要注意的是，inline必须于函数定义放置一起</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="C-头文件和实现函数分别写什么："><a href="#C-头文件和实现函数分别写什么：" class="headerlink" title="C++头文件和实现函数分别写什么："></a>C++头文件和实现函数分别写什么：</h1><h2 id="概览："><a href="#概览：" class="headerlink" title="概览："></a>概览：</h2><figure class="image-box">
                <img src="C:\Users\Render\AppData\Roaming\Typora\typora-user-images\image-20191110133905131.png" alt="image-20191110133905131" title="" class="">
                <p>image-20191110133905131</p>
            </figure>

<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>头文件的所有内容，都必须包含在<br>#ifndef {Filename}<br>#define {Filename}<br>//{Content of head file}<br>#endif<br><em>这样才能保证头文件被多个其他文件引用(include)时，内部的数据不会被多次定义而造成错误</em></p>
<h2 id="inline限定符"><a href="#inline限定符" class="headerlink" title="inline限定符"></a>inline限定符</h2><ul>
<li>在头文件中，可以对函数用inline限定符来告知编译器，这段函数非常的简单，可以直接嵌入到调用定义之处。</li>
<li>当然inline的函数并不一定会被编译器作为inline来实现，如果函数过于复杂，编译器也会拒绝inline。</li>
<li>因此简单说来，代码最好短到只有3-5行的才作为inline。有循环，分支，递归的函数都不要用做inline。</li>
<li>对于在类定义内定义实现的函数，编译器自动当做有inline请求（也是不一定inline的）。因此在下边，我把带有inline限定符的函数成员和写在类定义体内的函数成员统称为“要inline的函数成员”</li>
</ul>
<h2 id="非模版类型"><a href="#非模版类型" class="headerlink" title="非模版类型"></a>非模版类型</h2><h3 id="全局类型"><a href="#全局类型" class="headerlink" title="全局类型"></a>全局类型</h3><p>就像前面笼统的话讲的：声明写在.h文件。<br>对于函数来讲，没有实现体的函数，就相当于是声明；而对于数据类型（包括基本类型和自定义类型）来说，其声明就需要用extern来修饰。<br>然后在.cpp文件里定义、实现或初始化这些全局函数和全局变量。</p>
<h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>对于自定义类型，包括类（class）和结构体（struct），它们的定义都是放在.h文件中。<br>函数成员：<br>函数成员无论是否带有static限定符，其申明都放在.h文件的类定义内部。<br>对于要inline的函数成员其定义放在.h文件；其他函数的实现都放在.cpp文件中。<br>数据成员：<br>数据成员的申明与定义都是放在.h文件的类定义内部。对于数据类型，关键问题是其初始化要放在什么地方进行。</p>
<ul>
<li>对于只含有static限定符的数据成员，它的初始化要放在.cpp文件中。因为它是所有类对象共有的，因此必须对它做合适的初始化。</li>
<li>对于只含有const限定符的数据成员，它的初始化只能在构造函数的初始化列表中完成。因为它是一经初始化就不能重新赋值，因此它也必须进行合适的初始化。</li>
<li>对于既含有static限定符，又含有const限定符的数据成员，它的初始化和定义同时进行。它也是必须进行合适的初始化</li>
<li>对于既没有static限定符，又没有const限定符的数据成员，它的值只针对本对象可以随意修改，因此我们并不在意它的初始化什么时候进行。</li>
</ul>
<h2 id="模版类型"><a href="#模版类型" class="headerlink" title="模版类型"></a>模版类型</h2><p>对于模板，最重要的一点，就是在定义它的时候，编译器并不会对它进行编译，因为它没有一个实体可用。<br>只有模板被具体化（specialization）之后（用在特定的类型上），编译器才会根据具体的类型对模板进行编译。所以定义模板的时候，会发现编译器基本不会报错<br>因为模板的这种特殊性，它并没有自己的准确定义，因此我们不能把它放在.cpp文件中，而要把他们全部放在.h文件中进行书写。这也是为了在模板具体化的时候，能够让编译器可以找到模板的所有定义在哪里，以便真正的定义方法。</p>
<hr>
<h1 id="4-C-中的const修饰符"><a href="#4-C-中的const修饰符" class="headerlink" title="4.C++中的const修饰符"></a>4.C++中的const修饰符</h1><h2 id="const-修饰函数"><a href="#const-修饰函数" class="headerlink" title="const 修饰函数"></a>const 修饰函数</h2><p>表明该函数<strong>不修改类对象</strong>（不改变对象的非const成员变量. 也不能调用类中任何非const成员函数）。<br>格式：<strong>关键字const被放在成员函数的参数表（即“()”）和函数体（即“{}”）之间。</strong></p>
<ul>
<li>如下代码，const修饰的是函数x()。表示该函数的函数体中的操作不会修改当前这个类的类对象。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline float x()const&#123;return e[0];&#125;</span><br></pre></td></tr></table></figure></li>
<li>又如如下代码，const修饰的是函数operator+()。表示该函数的函数体中的操作不会修改当前这个类的类对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline const vec3&amp; operator+()const&#123;return *this;&#125;</span><br></pre></td></tr></table></figure></li>
<li>另外，对于在类体之外定义的const成员函数，我们必须在它的定义和声明中同时指定关键字const。比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline float x() const; //declaration</span><br><span class="line">inline float x() const&#123; //definition </span><br><span class="line">	return e[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="const-修饰函数参数"><a href="#const-修饰函数参数" class="headerlink" title="const 修饰函数参数"></a>const 修饰函数参数</h2>表示函数体中不能修改参数的值（包括参数本身的值或者参数其中包含的值）。比如如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline vec3&amp; vec3::operator+=(const vec3 &amp;v)&#123;</span><br><span class="line">	e[0]+=v.e[0];</span><br><span class="line">	e[1]+=v.e[1];</span><br><span class="line">	e[2]+=v.e[2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="const-修饰函数返回值"><a href="#const-修饰函数返回值" class="headerlink" title="const 修饰函数返回值"></a>const 修饰函数返回值</h2><ul>
<li>const修饰函数返回值：<br>其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1  .const int fun1()//函数返回的是值</span><br><span class="line">2.  const int* fun2()//函数返回的是指针，调用时:const int* pValue=fun2();</span><br><span class="line"></span><br><span class="line">3.  int* const fun3()</span><br><span class="line">//函数返回的是指针（不是值）：调用时 int* const pValue = fun3();</span><br><span class="line">//我们可以把fun3()看作成一个变量，即指针本身不可变。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>结合《RayTracing in One-Weekend》的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline const vec3&amp; operator+()&#123;return *this;&#125;</span><br></pre></td></tr></table></figure>
<p>这个就属于上面第二种情况，即函数operator+()返回的是一个vec3类型的对象的指针/引用。此处const表示该指针所指向的vec3类型的对象不可变。 </p>
<h1 id="C-中this指针"><a href="#C-中this指针" class="headerlink" title="C++中this指针"></a>C++中this指针</h1><p>每个类成员函数都含有一个指向被调用对象的指针，这个指针被称为this指针。<br>this表示被调用对象的指针；<br>*this表示被调用对象本身；<br>例如如下代码中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline void Screen::home()&#123;</span><br><span class="line">	this-&gt;cursor=0;</span><br><span class="line">&#125;</span><br><span class="line">//this表示被调用对象的指针</span><br><span class="line">//this-&gt;cursor表示被调用对象的成员变量cursor，此处对该成员变量赋值。</span><br></pre></td></tr></table></figure>
<p>又如之前多次引用的《RayTracing-OneWeekend》中的code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline vec3&amp; vec3::operator+=(const vec3&amp;v)&#123;</span><br><span class="line">	e[0]=v.e[0];</span><br><span class="line">	e[1]=v.e[1];</span><br><span class="line">	e[2]=v.e[2];</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于函数定义的函数返回是引用类型，即返回的不是值或者指针，而是对象本身。所以，此处需要return *this来返回对象本身，而不是return this（返回的是指针）。</p>
]]></content>
      
        <categories>
            
            <category> Computer-Science </category>
            
            <category> Programming Language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Programming Language </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++学习（一）]]></title>
      <url>/2019/11/05/C++_Learning_1/</url>
      <content type="html"><![CDATA[<h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><figure class="image-box">
                <img src="QQ截图20191016101925.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>
<ul>
<li>C++是面向对象程序设计语言<br>C++全面支持面向对象开发四大特性：</li>
<li>封装</li>
<li>抽象</li>
<li>继承</li>
<li>多态</li>
</ul>
<p>七种基本数据类型</p>
<ul>
<li>布尔值 bool</li>
<li>字符型 char</li>
<li>整型 int</li>
<li>浮点型 float</li>
<li>双浮点型 double</li>
<li>无类型 void</li>
<li>宽字符型 wchar_t</li>
</ul>
<p>类型修饰符</p>
<ul>
<li>signed</li>
<li>long</li>
<li>short</li>
<li>unsigned</li>
</ul>
<p>使用sizeof()获取数据类型长度：</p>
<figure class="image-box">
                <img src="QQ截图20191016105451.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>

<p>使用typedef关键字为一个已有的数据类型取一个新的名字（别名）</p>
<blockquote>
<p>typedef int fet;  //告诉编译器 fet是int的别名<br>fet a;  //使用别名声明变量</p>
</blockquote>
<p>枚举类型（enumeration）是C++中一个派生的数据类型</p>
<ul>
<li>由用户定义的若干枚举常量的集合</li>
</ul>
<figure class="image-box">
                <img src="test1.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>

<p>extern关键字在任何地方声明变量</p>
<h2 id="局部变量，全局变量"><a href="#局部变量，全局变量" class="headerlink" title="局部变量，全局变量"></a>局部变量，全局变量</h2><ul>
<li><p>全局变量：在所有函数外部定义的变量（通常在函数头部） 全局变量的值在程序的整个生命周期内都是有效的。全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。</p>
</li>
<li><p>局部变量：局部变量只能被函数内部或者代码块内部的语句使用。</p>
</li>
<li><figure class="image-box">
                <img src="test2.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>


</li>
</ul>
<h2 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h2><blockquote>
<p>float a= 3.14159<br>float b=314159E-5L //科学计数法写法</p>
</blockquote>
<h2 id="define-预处理器"><a href="#define-预处理器" class="headerlink" title="#define 预处理器"></a>#define 预处理器</h2><h2 id="域解析操作符"><a href="#域解析操作符" class="headerlink" title="::域解析操作符"></a>::域解析操作符</h2><p>行数较多的成员函数最好定义在类体之外（否则会默认为inline）<br>这要求使用特殊的声明语句来标识<br>通过::指定类域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline vec3&amp; vec3::operator+=(const vec3&amp;v)&#123;</span><br><span class="line">    e[0] += v.e[0];</span><br><span class="line">    e[1] += v.e[1];</span><br><span class="line">    e[2] += v.e[2];</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h2><ul>
<li>const关键字修饰的对象在程序执行期间不能被修改改变</li>
</ul>
<h2 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C++存储类"></a>C++存储类</h2><ul>
<li><p>C++存储类定义C++程序中 变量或函数的可见性和生命周期</p>
</li>
<li><p>register 存储类：用于定义在寄存器中而不是内存中的局部变量</p>
<blockquote>
<p> register int miles; //for example</p>
</blockquote>
</li>
<li><p>static存储类：表示编译器在程序的生命周期中保持局部变量的存储，而不需要在每次进入或离开作用域时创建或销毁。即：使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</p>
</li>
<li><p>static 修饰符也可以用于修饰全局变量，这会使变量的作用域限制在声明它的文件内</p>
</li>
<li><p>当 static 用在类数据成员上时，会使<strong>仅有一个</strong>该成员的<strong>副本</strong>被 当 static 用在类数据成员上时，会使仅有一个该成员的副本被类的所有对象共享。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">void func(void);</span><br><span class="line">static int count = 5;//全局静态变量</span><br><span class="line"></span><br><span class="line">void func( void )</span><br><span class="line">&#123;</span><br><span class="line">   static int i = 5; // 局部静态变量</span><br><span class="line">   i++;</span><br><span class="line">   std::cout &lt;&lt; &quot;变量 i 为 &quot; &lt;&lt; i ;</span><br><span class="line">   std::cout &lt;&lt; &quot; , 变量 count 为 &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   while(count--)</span><br><span class="line">   &#123;</span><br><span class="line">      func();</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="image-box">
                <img src="test3.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>



<ul>
<li><strong>extern 存储类</strong>：用来在另一个文件中声明一个全局变量和函数</li>
<li>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。</li>
<li><strong>使用 extern 时，对于没有初始化的变量，会把变量名指向一个之前定义过的存储位置。</strong></li>
<li>当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用extern 来得到已定义的变量或函数的引用。</li>
<li>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数</li>
</ul>
<p>main.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int count ;</span><br><span class="line">extern void write_extern();</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   count = 4;</span><br><span class="line">   write_extern();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>support.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">extern int count;</span><br><span class="line">void write_extern(void)</span><br><span class="line">&#123;</span><br><span class="line">   std::cout &lt;&lt; &quot;Count is &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>thread_local存储类：<strong>修饰的变量仅可在它在其上创建的线程上访问。</strong></li>
<li>变量在创建线程时创建，并在销毁线程时销毁。</li>
<li>每个线程都有其自己的变量副本。</li>
<li>thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</li>
</ul>
<h2 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C++ 运算符"></a>C++ 运算符</h2><ul>
<li>&amp; ：指针运算符，返回变量的地址。</li>
<li>* ：指针运算符，指向一个变量。</li>
</ul>
<h1 id="C-函数调用形式"><a href="#C-函数调用形式" class="headerlink" title="C++函数调用形式"></a>C++函数调用形式</h1><table>
<thead>
<tr>
<th>调用类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>传值调用</td>
<td>把参数的实际值复制给函数的形式参数<br/>在这种情况下，修改函数内的形式参数对实际参数没有影响</td>
</tr>
<tr>
<td><strong>指针调用</strong></td>
<td>把参数的地址复制给形式参数<br/>在函数内，该地址用于访问调用中要用到的实际参数<br/>这意味着，修改形式参数会影响实际参数</td>
</tr>
<tr>
<td><strong>引用调用</strong></td>
<td>把参数的引用复制给形式参数<br/>在函数内，该引用用于访问调用中要用到的实际参数<br/>这意味着，修改形式参数会影响实际参数</td>
</tr>
</tbody></table>
<ul>
<li>默认情况下，C++ 使用 传值调用 来传递参数，这意味着函数内的代码不能改变用于调用函数的参数</li>
</ul>
<h2 id="C-Lambda函数"><a href="#C-Lambda函数" class="headerlink" title="C++　Lambda函数"></a>C++　Lambda函数</h2><p>未看</p>
<h1 id="C-数组"><a href="#C-数组" class="headerlink" title="C++ 数组"></a>C++ 数组</h1><ol>
<li><p>初始化：</p>
<blockquote>
<p>/*第一种：逐个初始化数组*/<br>double arr[3];<br>arr[0]=1;<br>arr[1]=2;<br>arr[2]=3;<br>/*第二种：声明的同时使用｛｝初始化数组*/<br>double arr[]={1,2,3}; //或 double arr[3]={1,2,3};</p>
</blockquote>
</li>
<li><p>多维数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//二维数组的初始化</span><br><span class="line">int a[3][4] = &#123;  </span><br><span class="line"> &#123;0, 1, 2, 3&#125; ,   /*  初始化索引号为 0 的行 */</span><br><span class="line"> &#123;4, 5, 6, 7&#125; ,   /*  初始化索引号为 1 的行 */</span><br><span class="line"> &#123;8, 9, 10, 11&#125;   /*  初始化索引号为 2 的行 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传递数组给函数（三种形式）</p>
</li>
</ol>
<ul>
<li><p>形式参数是一个指针：</p>
<blockquote>
<p>void myFunction(int * parm){}</p>
</blockquote>
</li>
<li><p>形式参数是一个已定义大小的数组：</p>
<blockquote>
<p>void myFunction(int parm[10]){}</p>
</blockquote>
</li>
<li><p>形式参数是一个未定义大小的数组：</p>
<blockquote>
<p>void myFunction(int []parm){}</p>
</blockquote>
</li>
</ul>
<p>*<em>这三种声明方式的结果是一样的，因为每种方式都会告诉编译器将要接收一个整型指针 *</em></p>
<ol start="4">
<li>函数返回数组</li>
</ol>
<ul>
<li><p>C++不允许函数返回一个完整的数组 比如：int [] myFunction(){}是错误的</p>
</li>
<li><p>但是可以指定不带索引的数组名来返回一个指向数组的指针，</p>
<blockquote>
<p>void * myFunction(){} //正确</p>
</blockquote>
</li>
<li><p>C++不支持在函数外返回局部变量的地址，除非局部变量是static变量<br>例如：int * myFunction(){<br>  int arr[] myarr;<br>  return myarr; // 错误，不能返回局部变量<br>}</p>
<blockquote>
<p>int * myFunction(){<br>   static int arr[] myarr;<br>   return myarr; // 可以，因为是静态局部变量<br>}</p>
</blockquote>
</li>
<li><p>*得到的是对应地址的值，&amp; 得到的是相应的地址</p>
</li>
</ul>
<figure class="image-box">
                <img src="test4.png" alt="[sorry,图片挂了]" title="[程序截图]" class="[samll]">
                <p>[程序截图]</p>
            </figure>

<figure class="image-box">
                <img src="test5.png" alt="[sorry,图片挂了]" title="[程序截图]" class="[samll]">
                <p>[程序截图]</p>
            </figure>


<h1 id="C-指针"><a href="#C-指针" class="headerlink" title="C++ 指针"></a>C++ 指针</h1><ul>
<li>变量是对程序中数据存储空间的一种抽象</li>
<li>内存中的每个字节都有一个编号——地址</li>
<li><em>取地址符&amp;*</em><br>取地址符&amp;获得一个变量的内存地址</li>
</ul>
<p><strong>解地址符*</strong><br>解地址符*获得一个内存地址保存的值</p>
<ul>
<li>指针是一个变量，其值为<strong>另一个变量的地址</strong>，即：内存位置的直接地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int    *ip;    /* 一个整型的指针 */</span><br><span class="line">double *dp;    /* 一个 double 型的指针 */</span><br><span class="line">float  *fp;    /* 一个浮点型的指针 */</span><br><span class="line">char   *ch;    /* 一个字符型的指针 */</span><br></pre></td></tr></table></figure>

<ul>
<li>所有指针的值的实际数据类型都是一样的，都是一个代表内存地址的长的16进制数 </li>
<li>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同</li>
</ul>
<p>C++中指针的五种操作 </p>
<ul>
<li>1.定义一个指针变量*<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *ptr_a;</span><br></pre></td></tr></table></figure></li>
<li>2.把变量地址赋给指针，使用取地址符*<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pi = 3.1415926;</span><br><span class="line">int *ptr_pi = &amp;pi; //这里的*是声明指针并不是取解地址符</span><br></pre></td></tr></table></figure></li>
<li>3.访问指针变量中可用地址的值，使用解地址符*<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pi = 3.1415926;</span><br><span class="line">int *ptr_pi = &amp;pi;</span><br><span class="line">std::cout &lt;&lt; *ptr_pi;</span><br></pre></td></tr></table></figure></li>
<li>4.简单的自增自减和加法减法运算符<br>因为指针保存的是变量的地址，而变量的地址是十六进制整形，所以也支持四种操作，而且只支持这四种</li>
<li>5.简单的比较两个指针的大小,可以使用三个比较运算符 ==、&lt; 和 &gt;<br>这三个比较运算符用于比较指针指向的内存地址是否相等，是否大于或小于</li>
</ul>
<h1 id="C-编程范例"><a href="#C-编程范例" class="headerlink" title="C++编程范例"></a>C++编程范例</h1><ul>
<li><ol>
<li>NULL空指针<br>声明指针变量的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯</li>
</ol>
</li>
</ul>
<ul>
<li>2.指针VS数组<br>C++ 中的指针和数组是密切相关的，指针和数组在很多情况下是可以互换的<br>一个指向数组开头的指针，可以通过使用指针的算术运算或数组索引来访问数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> #include  &lt;iostream&gt;</span><br><span class="line">  const int LEN=5;</span><br><span class="line"> int main()&#123;</span><br><span class="line">	int arr[LEN]=&#123;8,16,32,64,128&#125;;</span><br><span class="line">	//定义指针指向数组地址</span><br><span class="line">	int *ptr=arr;</span><br><span class="line">	//还可以将上一行代替为：int *ptr;   ptr=arr;</span><br><span class="line">	for(int i=0;i&lt;LEN;i++)&#123;</span><br><span class="line">		std::cout  &lt;&lt; &quot;arr[&quot; &lt;&lt; i &lt;&lt; &quot;]的内存地址为 &quot;;</span><br><span class="line">	    std::cout &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line">	    std::cout &lt;&lt; &quot;var[&quot; &lt;&lt; i &lt;&lt; &quot;] 的值为 &quot;;</span><br><span class="line">	    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">	    // 移动到下一个位置</span><br><span class="line">	    ptr++;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>但是<br>指针和数组并不是完全互换的，就是数组变量是不能做自增自减和加减法赋值给自己<br>    int  arr[LEN] = {8, 16, 32,64,128};<br>    for (int i = 0; i &lt; MAX; i++)<br>    {<br>        *arr = i;    // 这是正确的语法<br>        arr++;       // 这是不正确的<br>    }<br>//即：数组名可以指向数组第一个元素地址，可以当作指针使用<br>//但是不能够改变数组名指向数组第一元素的事实    </p>
<ul>
<li><p>3.指针数组</p>
</li>
<li><p><em>C++ 中 数组名是一个指向数组中第一个元素的常量指针*</em><br>即：</p>
<blockquote>
<p>double balance[50];<br>balance是一个指向&amp;balance[0]的指针，即数组 balance 的第一个元素的地址<br>因此：*(balance + 4) 是一种访问 balance[4] 数据的合法方式</p>
</blockquote>
</li>
<li><p>4.C++指向指针的指针（多级间接寻址）<br>指向指针的指针，就是一个指针指向的地址保存的是另一个指针的地址，另一个指针保存的才是实际值的位置</p>
</li>
</ul>
<figure class="image-box">
                <img src="test6.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>
<blockquote>
<p>int **var;//多级间接寻址</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">double i=3;</span><br><span class="line">double *p_i=&amp;i;</span><br><span class="line">double **pp_i=&amp;p_i;</span><br></pre></td></tr></table></figure>
<h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><h2 id="引用-amp"><a href="#引用-amp" class="headerlink" title="引用&amp;"></a>引用&amp;</h2><p>引用 针对的是变量，这个要和 typedef 针对类型区分开来<br>可以在数据类型和变量名之间加上一个 &amp; 符号来声明一个引用，就像下面这样</p>
<blockquote>
<p>int a=8;<br>int &amp;b=a;//正确，需要区别等式的左值和右值<br>这里&amp;是在左值，不能看作是取地址符，而是声明引用的一种格式<br>&amp;出现在右值时才是取地址符</p>
</blockquote>
<p>不能直接指向数据<br>  int &amp;b=8；//错误</p>
<h3 id="指针和引用的区别："><a href="#指针和引用的区别：" class="headerlink" title="指针和引用的区别："></a>指针和引用的区别：</h3><p>1.引用必须在创建时被初始化。指针可以在任何时间被初始化<br>    int &b; // 错误<br>2.不存在空引用。引用必须连接到一块合法的内存，也就是不能有如下的声明<br>    int &amp;c = NULL;   // 错误</p>
<h2 id="引用的使用"><a href="#引用的使用" class="headerlink" title="引用的使用"></a>引用的使用</h2><h3 id="引用作为参数"><a href="#引用作为参数" class="headerlink" title="引用作为参数"></a>引用作为参数</h3><p>引用可以像指针一样作为函数的参数，使用方式和指针一模一样<br>相比传一般的参数更加的安全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> void swap(int &amp;a,int &amp;b)&#123;</span><br><span class="line">	int temp=a;</span><br><span class="line">	a=b;</span><br><span class="line">	b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用作为返回值"><a href="#引用作为返回值" class="headerlink" title="引用作为返回值"></a>引用作为返回值</h3><p>函数也可以返回一个引用，方式与返回一个指针类似，<strong>通常的做法是使用引用替代指针</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> double nums[]=&#123;11.11, 12.58, 12.21, 25.25, 88.8&#125;;</span><br><span class="line"> double&amp; setNum(int i)&#123;</span><br><span class="line">	return nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数返回一个引用时，返回的是一个指向返回值的隐式指针<br>因此，我们可以把返回引用的函数作为左值，例如</p>
<blockquote>
<p>setNum(1)=203.0;</p>
</blockquote>
<p>例如实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">double nums[] = &#123;11.11, 12.58, 12.21, 25.25, 88.8&#125;;</span><br><span class="line"> double&amp; setNums(int i)&#123;</span><br><span class="line">	return nums[i]; 	</span><br><span class="line"> &#125;  </span><br><span class="line"> int main()&#123;</span><br><span class="line">	setNums(1)=203.0;//改变引用的值</span><br><span class="line">	std::cout&lt;&lt; setNums(1);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：203.0</p>
<ul>
<li>通常传递的是形参的值或者地址的值。此时需要将形参的值拷贝（赋值）给实参，然后操纵实参。</li>
</ul>
<p>当把参数声明为引用时，传递的是形参本身。<br>此时不需要将形参的值拷贝（赋值）给实参，可以直接操纵形参。和指针类似。<br>如下代码，形参v是一个vec3类型对象的引用，所以函数体内可以直接操作v对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline vec3&amp; vec3::operator+=(const vec3&amp; v)&#123;</span><br><span class="line">	e[0]=v.e[0];</span><br><span class="line">	e[1]=v.e[1];</span><br><span class="line">	e[2]=v.e[2];</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.当返回一个引用时，被引用的对象不能超出作用域<br>返回一个对局部变量的引用是不合法的。<br>int&amp; func() {<br>   int q;<br>   return q;  // 在编译时发生错误<br>}</p>
<p>2.可以返回一个对静态变量的引用<br>int&amp; func() {<br>   static int x;<br>   return x;     // 安全，x 在函数作用域外依然是有效的<br>}</p>
<p>3.引用必须被初始化，不允许空引用，且引用一旦初始化后就不能引用其他数据</p>
<h2 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h2><p>引用能干的事情，指针都能干<br>那么问题来了，为什么还要“引用”这东西？<br>网友给出一个非常好的解释：（够用，简单，可靠）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    答案是“用适当的工具做恰如其分的工作”。</span><br><span class="line">    指针能够毫无约束地操作内存中的如何东西，尽管指针功能强大，但是非常危险。</span><br><span class="line">    就象一把刀，它可以用来砍树、裁纸、修指甲、理发等等，谁敢这样用？</span><br><span class="line">如果的确只需要借用一下某个对象的“别名”，那么就用“引用”，而不要用“指针”，以免发生意外。比如说，某人需要一份证明，本来在文件上盖上公章的印子就行了，如果把取公章的钥匙交给他，那么他就获得了不该有的权利。</span><br></pre></td></tr></table></figure>

<h1 id="Some-Tips"><a href="#Some-Tips" class="headerlink" title="Some Tips"></a>Some Tips</h1><h2 id="使用-ifdef和-pragam-once两种方式避免一个文件被include多次"><a href="#使用-ifdef和-pragam-once两种方式避免一个文件被include多次" class="headerlink" title="使用#ifdef和#pragam once两种方式避免一个文件被include多次"></a>使用#ifdef和#pragam once两种方式避免一个文件被include多次</h2><p><em>(不要拼措了，是pragam，不是program)</em></p>
<p>#ifdef受到C/C++语言标准支持，不会受到编译器的限制，而#pragma once一般由编译器提供保证。<br>#pragma once 的兼容性不如#if def</p>
<h2 id="定义类结构时，需要显式public参数或方法"><a href="#定义类结构时，需要显式public参数或方法" class="headerlink" title="定义类结构时，需要显式public参数或方法"></a>定义类结构时，需要显式public参数或方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class vec3&#123;</span><br><span class="line">	public:</span><br><span class="line">		float e[3];</span><br><span class="line">	</span><br><span class="line">	vec3()&#123;&#125;</span><br><span class="line">	vec3(float e1, float e2,float e3)&#123;</span><br><span class="line">		e[0] = e1;</span><br><span class="line">		e[1] = e2;</span><br><span class="line">		e[2] = e3;</span><br><span class="line">&#125;</span><br><span class="line">	inline float r()&#123;</span><br><span class="line">		return e[0];</span><br><span class="line">	&#125;</span><br><span class="line">	inline float g()&#123;</span><br><span class="line">		return e[1];</span><br><span class="line">	&#125;</span><br><span class="line">	inline float b()&#123;</span><br><span class="line">		return e[2];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dot-A-B"><a href="#dot-A-B" class="headerlink" title="dot(A ,B)"></a>dot(A ,B)</h2><p>可以进行点乘运算  </p>
<h2 id="基本运算函数"><a href="#基本运算函数" class="headerlink" title="基本运算函数"></a>基本运算函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pow(a，b)幂运算</span><br><span class="line">sqrt(a)开平方根</span><br><span class="line">abs(a)整数求绝对值</span><br><span class="line">fabs(a)浮点数求绝对值</span><br></pre></td></tr></table></figure>


<h2 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h2><blockquote>
<p>class derived-class  :  access-specifier base-class<br>//derived-class 派生类   base-class 基类  access-specifer 访问修饰符（private ,public, &gt;protected）<br>eg   class Dustman: public Worker</p>
<ul>
<li><strong>如果没有使用访问修饰符，那么默认为private</strong> </li>
</ul>
</blockquote>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>纯虚函数没有函数体</p>
<pre><code>class shape{
 public:
  virtual double calcPerimeter()=0//纯虚函数
 }</code></pre><p>不可实例化含有虚函数的基类</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul>
<li>抽象类无法实例化对象</li>
</ul>
<h2 id="rand-函数"><a href="#rand-函数" class="headerlink" title="rand()函数"></a>rand()函数</h2><ul>
<li>rand()不需要参数，它会返回一个从0到最大随机数的任意整数，</li>
<li>如果你要产生一个0~99这100个整数的一个随机整数，可以表达为:<blockquote>
<p>int num=rand()%100;</p>
</blockquote>
</li>
<li>如果要产生一个1~100这100个整数的一个随机整数，可以表达为：<blockquote>
<p>int num=rand()%100+1;</p>
</blockquote>
</li>
</ul>
<hr>
]]></content>
      
        <categories>
            
            <category> Computer-Science </category>
            
            <category> Programming Language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Programming Language </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Matlab相关]]></title>
      <url>/2019/11/05/Matlab_Learning/</url>
      <content type="html"><![CDATA[<h1 id="Matlab学习"><a href="#Matlab学习" class="headerlink" title="Matlab学习"></a>Matlab学习</h1><h3 id="1-dir-使用"><a href="#1-dir-使用" class="headerlink" title="1. dir()使用"></a>1. dir()使用</h3><p>dir函数可以有调用方式</p>
<ul>
<li><p>dir(‘.’) 列出当前目录下所有子文件夹和文件</p>
</li>
<li><p>dir(‘G:\Matlab’) 列出指定目录下所有子文件夹和文件</p>
</li>
<li><p>dir(‘*.m’) 列出当前目录下符合正则表达式的文件夹和文件</p>
</li>
<li><p>得到的为结构体数组每个元素都是如下形式的结构体</p>
<pre><code>name  -- filename
date  -- modification date
bytes  -- number of bytes allocated to the file
isdir  -- 1 if name is a directory and 0 if not
datenum -- modification date as a MATLAB serial date number</code></pre><p> 分别为文件名,修改日期,大小,是否为目录,Matlab特定的修改日期</p>
<p>可以提取出文件名以作读取和保存用.</p>
</li>
</ul>
<h3 id="2-exist-使用"><a href="#2-exist-使用" class="headerlink" title="2. exist()使用"></a>2. exist()使用</h3><ul>
<li>判断某个变量，函数，类，文件夹等参数是否存在。</li>
<li>A=exists(“name”,”kind”)，name可以是变量，函数，类，文件夹等</li>
<li>返回值的含义如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 不存在则返回值 </span><br><span class="line">1 name 可以是变量名，如果存在，返回值 </span><br><span class="line">2 函数名、m 文件名，存在则返回值 </span><br><span class="line">3 mex 文件、dll 文件，存在则返回值</span><br><span class="line">4 内嵌的函数，存在则返回值 5 p码文件 ， 存在则返回值 </span><br><span class="line">6 目录，存在则返回值 </span><br><span class="line">7 路径，存在则返回值 </span><br><span class="line">8 Java class，存在则返回值</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3. for循环"></a>3. for循环</h3><ul>
<li>for k=1:10  正序遍历</li>
<li>for k=10:-1:1 倒序遍历，从10到1，每次递减-1</li>
</ul>
<h3 id="4-strrep-使用"><a href="#4-strrep-使用" class="headerlink" title="4.strrep()使用"></a>4.strrep()使用</h3><ul>
<li>查找并替换函数</li>
<li>strrep(A,B,C); 在A中查找B并替换为C</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Computer-Science </category>
            
            <category> Programming Language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Programming Language </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VS使用及错误合集]]></title>
      <url>/2019/11/04/Basic_Software_Use_VS/</url>
      <content type="html"><![CDATA[<h1 id="1-错误合集"><a href="#1-错误合集" class="headerlink" title="1.错误合集"></a>1.错误合集</h1><hr>
<h3 id="1-1-ErrorLINK2019无法解析的外部符号-WinMain-16"><a href="#1-1-ErrorLINK2019无法解析的外部符号-WinMain-16" class="headerlink" title="1.1 .ErrorLINK2019无法解析的外部符号_WinMain@16"></a>1.1 .ErrorLINK2019无法解析的外部符号_WinMain@16</h3><ul>
<li>原因：无法找到适当的程序入口函数，其中Windows程序和控制台程序Console的入口程序不一致，应该在项目配置信息中选择适当预处理器以及链接器中合适的子系统。</li>
</ul>
<ul>
<li><figure class="image-box">
                <img src="VS1.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>
</li>
<li><p>解决：</p>
</li>
</ul>
<ul>
<li><figure class="image-box">
                <img src="VS2.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>


</li>
</ul>
<h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h1><hr>
<ul>
<li>Ctrl+Shift+B：生成解决方案，形成可执行文件。</li>
<li>生成可执行文件后有两种形式，其中一种是调试，一种是直接执行不调试</li>
<li>(F5或Alt+F5)在调试程序过程中，若遇到断点，会停止在断点处，等待继续运行的指令，当程序运行完毕后不会直接退出，而会暂停程序。</li>
<li>(Ctrl+F5)直接执行程序（不调试），完全忽略断点，程序运行完毕后直接结束程序。</li>
</ul>
<hr>
<h2 id="在VS2017中安装配置OpenGL教程："><a href="#在VS2017中安装配置OpenGL教程：" class="headerlink" title="在VS2017中安装配置OpenGL教程："></a>在VS2017中安装配置OpenGL教程：</h2><p><a href="http://www.cnblogs.com/flylinmu/p/7823019.html" target="_blank" rel="noopener">http://www.cnblogs.com/flylinmu/p/7823019.html</a></p>
<p>注意：</p>
<ul>
<li><p>（1）.在VS中对于项目进行属性配置时，右键点击解决方案中的项目名称，选择“属性配置”。</p>
</li>
<li><p>（2）.在VS2017中新建一个Windows控制台项目时，会自动生成一个pch.h文件，项目将其默认为预编译头文件，当项目较大时，可以在pch.h头文件中加入大量的宏定义，便于后期的维护更新，但是当项目较小时，可以在项目配置中，选择C/C++,将预编译头省略。</p>
</li>
<li><p>相关博客：<br><a href="http://www.blog.csdn.net/weixin_43074474/article/details/89520392" target="_blank" rel="noopener">http://www.blog.csdn.net/weixin_43074474/article/details/89520392</a></p>
</li>
</ul>
<hr>
<h2 id="VS快捷键"><a href="#VS快捷键" class="headerlink" title="VS快捷键"></a>VS快捷键</h2><ul>
<li>Alt+→：代码提示代码</li>
<li>注释代码：Ctrl+K选中后再C</li>
<li>取消注释代码：Ctrl+K选中后再U</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 开发工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> Visual Studio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开发工具推荐及相关使用]]></title>
      <url>/2019/11/04/Basic_Software_Use/</url>
      <content type="html"><![CDATA[<h1 id="开发工具及使用"><a href="#开发工具及使用" class="headerlink" title="开发工具及使用"></a>开发工具及使用</h1><p>+++</p>
<h3 id="1-listary"><a href="#1-listary" class="headerlink" title="1. listary"></a>1. listary</h3><ul>
<li>双击Ctrl全局搜索</li>
<li>在文件管理器中双击空白处进行列表呼出</li>
</ul>
<h3 id="2-cmd"><a href="#2-cmd" class="headerlink" title="2.cmd"></a>2.cmd</h3><ul>
<li>在当前文件目录的显示栏下输入 cmd ,即可在当前路径下打开命令行</li>
</ul>
<h3 id="3-stb-image简单图像库"><a href="#3-stb-image简单图像库" class="headerlink" title="3,stb_image简单图像库"></a>3,stb_image简单图像库</h3><ul>
<li><p>重点关注三个头文件</p>
</li>
<li><figure class="image-box">
                <img src="1570780034511.png.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">
                <p>[image]</p>
            </figure>

</li>
</ul>
<h3 id="4-Windows-OS"><a href="#4-Windows-OS" class="headerlink" title="4.Windows OS"></a>4.Windows OS</h3><ul>
<li>Shift+F10:鼠标右键快捷键</li>
<li>Win+Ctrl+←/→：窗口切换，保命技巧</li>
</ul>
<h3 id="5-RenderDoc"><a href="#5-RenderDoc" class="headerlink" title="5.RenderDoc"></a>5.RenderDoc</h3><ul>
<li>可集成到VS或者Unity3D中</li>
</ul>
<h3 id="6-Typora"><a href="#6-Typora" class="headerlink" title="6. Typora"></a>6. Typora</h3><ul>
<li>Ctrl+/：源代码模式进入或者退出</li>
</ul>
<h3 id="7-Visual-Studio-Code"><a href="#7-Visual-Studio-Code" class="headerlink" title="7. Visual Studio Code"></a>7. Visual Studio Code</h3><ul>
<li>Ctrl+Shift+P:调出主命令框</li>
<li>Ctrl +K选中后，再按V：预览markdown效果</li>
</ul>
<h3 id="8-Scons"><a href="#8-Scons" class="headerlink" title="8. Scons"></a>8. Scons</h3><ul>
<li>基于python的软件构建工具</li>
</ul>
<h3 id="9-Python"><a href="#9-Python" class="headerlink" title="9.Python"></a>9.Python</h3><p>在同一计算机上同时配置两个不同版本的Python时，例如Python2.7以及Python3.6两个版本，可以在Python27文件夹下将python.exe文件更名为python27.exe，然后在用户环境变量下的Path下维护两个版本的Python地址，每个版本两个地址（一个Python文件夹地址，一个Script地址）</p>
]]></content>
      
        <categories>
            
            <category> 开发工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Tips </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Basic Tips about CS or SE]]></title>
      <url>/2019/11/04/Tips/</url>
      <content type="html"><![CDATA[<h3 id="1-HDR（High-Dynamic-Range）"><a href="#1-HDR（High-Dynamic-Range）" class="headerlink" title="1. HDR（High Dynamic Range）"></a>1. HDR（High Dynamic Range）</h3><ul>
<li>相比普通的图像，可以提供更多的动态范围和图像细节，根据不同的曝光时间的LDR（Low Dynamic Range）图像，相对应每个曝光时间对应最佳细节的LDR图像来合成最终的HDR图像，能够更好的反映除真实环境中的视觉效果。<a id="more"></a></li>
<li><ul>
<li>简单来说，就是一张图片中尽可能的显示最亮和最暗的地方。</li>
</ul>
</li>
<li>通过将拍出的几张不同曝光的照片，将每张照片曝光正常的部分保留，合成一张，就得到了一条了一张HDR图像。</li>
</ul>
<h3 id="2-HDR合成"><a href="#2-HDR合成" class="headerlink" title="2. HDR合成"></a>2. HDR合成</h3><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><ul>
<li>Unity中对于动态物体，例如人物等，使用Light Probe对于间接光照进行处理，Light Probe（采样点）对环境进行采样（发生在预处理阶段），在运行阶段，渲染器从邻近的采样点中取值，并对点进行插值处理。</li>
</ul>
<h3 id="4-计算机图形学（Computer-Graphics）和计算机视觉-Computer-Version"><a href="#4-计算机图形学（Computer-Graphics）和计算机视觉-Computer-Version" class="headerlink" title="4. 计算机图形学（Computer Graphics）和计算机视觉(Computer Version)"></a>4. 计算机图形学（Computer Graphics）和计算机视觉(Computer Version)</h3><ul>
<li>计算机图形（Computer Graphics）和计算机视觉（Computer Vision）是一对孪生兄弟，二者互为逆过程。</li>
<li><ul>
<li>计算机图形是预先知道3D物体的形状、位置、材料构成，以及场景的灯光和相机，然后渲染出场景。</li>
</ul>
</li>
<li>计算机视觉是已知拍到的图像，从中推断出有哪些物体，它们由什么材料制成，以及它们的3D位置和方向。</li>
</ul>
<h3 id="5-Mitsuba"><a href="#5-Mitsuba" class="headerlink" title="5. Mitsuba"></a>5. Mitsuba</h3><ul>
<li>一个面向研究用的开源软件，基于PBRT(Physically based rendering technology) 根据几何光学的物理性质编程实现</li>
<li>性能：实现了大多数常见的渲染算法</li>
<li>鲁棒性（Robustness）:采用底层算法（underlying algorithm）</li>
<li>可扩展性：可以并行计算，用大型计算簇实现与优化加速</li>
<li>限制：对于光的波特性无法很好的表现</li>
<li>极其模块化，它由一小组核心库和100多种不同的插件组成，这些插件实现了从材料和光源到完整渲染算法的功能。</li>
<li>与其他开源渲染器相比，Mitsuba非常重视实验渲染技术，例如Metropolis LightTransport的路径配方和体积建模方法。 因此，对于那些想要尝试这种尚未进入主流渲染器的技术的人来说，它可能是真正感兴趣的，它也为这一领域的研究提供了坚实的基础。</li>
</ul>
<h3 id="6-Tips"><a href="#6-Tips" class="headerlink" title="6.Tips"></a>6.Tips</h3><ul>
<li><p>jpg不支持透明度，有损压缩的图像格式，有损压缩会使得原始图片数据质量下降，也使得其占用空间小，在网页应用中加速速度快。</p>
</li>
<li><p>png支持透明度，无视压缩的图像格式，能在保证不失真的情况下尽可能压缩图像文件的大小，因此图像质量高，在一些贴纸应用中大多采用png图片。</p>
</li>
<li><p>Markdown：一种使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使得普通文本具有一定的格式。<br>Markdown具有一系列的衍生版本，用于扩展Markdown功能（例如：表格，脚注，内嵌HTML等）</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Computer-Science </category>
            
            <category> Basic Tips </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello Graphic World]]></title>
      <url>/2019/11/04/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="创建新的分页"><a href="#创建新的分页" class="headerlink" title="创建新的分页"></a>创建新的分页</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page XXX</span><br></pre></td></tr></table></figure>
<h3 id="创建新的博文"><a href="#创建新的博文" class="headerlink" title="创建新的博文"></a>创建新的博文</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new XXX</span><br></pre></td></tr></table></figure>

<ul>
<li>使用图像资源的相对路径的话，需要在yml文件中设置，并且在_posts文件中创建一个与博文名称一致的文件夹，并将图像资源放置其中。</li>
</ul>
]]></content>
      
        
    </entry>
    
  
  
</search>
