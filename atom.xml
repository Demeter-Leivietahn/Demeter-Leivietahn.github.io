<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tan桑のBlog</title>
  
  <subtitle>见证一个图形程序员的成长！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-11T04:47:11.885Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Leivie_Tan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++学习（一）</title>
    <link href="http://yoursite.com/2019/11/05/C++_Learning_1/"/>
    <id>http://yoursite.com/2019/11/05/C++_Learning_1/</id>
    <published>2019-11-05T01:56:27.000Z</published>
    <updated>2019-11-11T04:47:11.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><figure class="image-box">                <img src="QQ截图20191016101925.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure><ul><li>C++是面向对象程序设计语言<br>C++全面支持面向对象开发四大特性：</li><li>封装</li><li>抽象</li><li>继承</li><li>多态</li></ul><p>七种基本数据类型</p><ul><li>布尔值 bool</li><li>字符型 char</li><li>整型 int</li><li>浮点型 float</li><li>双浮点型 double</li><li>无类型 void</li><li>宽字符型 wchar_t</li></ul><p>类型修饰符</p><ul><li>signed</li><li>long</li><li>short</li><li>unsigned</li></ul><p>使用sizeof()获取数据类型长度：</p><figure class="image-box">                <img src="QQ截图20191016105451.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure><p>使用typedef关键字为一个已有的数据类型取一个新的名字（别名）</p><blockquote><p>typedef int fet;  //告诉编译器 fet是int的别名<br>fet a;  //使用别名声明变量</p></blockquote><p>枚举类型（enumeration）是C++中一个派生的数据类型</p><ul><li>由用户定义的若干枚举常量的集合</li></ul><figure class="image-box">                <img src="test1.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure><p>extern关键字在任何地方声明变量</p><h2 id="局部变量，全局变量"><a href="#局部变量，全局变量" class="headerlink" title="局部变量，全局变量"></a>局部变量，全局变量</h2><ul><li><p>全局变量：在所有函数外部定义的变量（通常在函数头部） 全局变量的值在程序的整个生命周期内都是有效的。全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。</p></li><li><p>局部变量：局部变量只能被函数内部或者代码块内部的语句使用。</p></li><li><figure class="image-box">                <img src="test2.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure></li></ul><h2 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h2><blockquote><p>float a= 3.14159<br>float b=314159E-5L //科学计数法写法</p></blockquote><h2 id="使用条件编译（-if-endif）避免多次修改main-函数"><a href="#使用条件编译（-if-endif）避免多次修改main-函数" class="headerlink" title="使用条件编译（#if #endif）避免多次修改main 函数"></a>使用条件编译（#if #endif）避免多次修改main 函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define testNumber 3</span><br><span class="line">#if testNumber==1;//output the  first image</span><br><span class="line">//完整的测试代码1</span><br><span class="line">#elif testNumber==2;//output the second image</span><br><span class="line">//完整的测试代码2</span><br><span class="line">#elif testNumber==3;//output the third image</span><br><span class="line">//完整的测试代码3</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>即是：<br>可以通过修改宏定义中testNumber的值来控制编译的代码块，也就是控制测试模块。<br>想测试哪一块，就将testNumber修改成对应的值即可；<br>想添加一个新的测试块，在添加一个“#elif testNumber == …”即可。</p><h2 id="域解析操作符"><a href="#域解析操作符" class="headerlink" title="::域解析操作符"></a>::域解析操作符</h2><p>行数较多的成员函数最好定义在类体之外（否则会默认为inline）<br>这要求使用特殊的声明语句来标识<br>通过::指定类域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline vec3&amp; vec3::operator+=(const vec3&amp;v)&#123;</span><br><span class="line">    e[0] += v.e[0];</span><br><span class="line">    e[1] += v.e[1];</span><br><span class="line">    e[2] += v.e[2];</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h2><ul><li>const关键字修饰的对象在程序执行期间不能被修改改变</li></ul><h2 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C++存储类"></a>C++存储类</h2><ul><li><p>C++存储类定义C++程序中 变量或函数的可见性和生命周期</p></li><li><p>register 存储类：用于定义在寄存器中而不是内存中的局部变量</p><blockquote><p> register int miles; //for example</p></blockquote></li><li><p>static存储类：表示编译器在程序的生命周期中保持局部变量的存储，而不需要在每次进入或离开作用域时创建或销毁。即：使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</p></li><li><p>static 修饰符也可以用于修饰全局变量，这会使变量的作用域限制在声明它的文件内</p></li><li><p>当 static 用在类数据成员上时，会使<strong>仅有一个</strong>该成员的<strong>副本</strong>被 当 static 用在类数据成员上时，会使仅有一个该成员的副本被类的所有对象共享。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">void func(void);</span><br><span class="line">static int count = 5;//全局静态变量</span><br><span class="line"></span><br><span class="line">void func( void )</span><br><span class="line">&#123;</span><br><span class="line">   static int i = 5; // 局部静态变量</span><br><span class="line">   i++;</span><br><span class="line">   std::cout &lt;&lt; &quot;变量 i 为 &quot; &lt;&lt; i ;</span><br><span class="line">   std::cout &lt;&lt; &quot; , 变量 count 为 &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   while(count--)</span><br><span class="line">   &#123;</span><br><span class="line">      func();</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="image-box">                <img src="test3.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure><ul><li><strong>extern 存储类</strong>：用来在另一个文件中声明一个全局变量和函数</li><li>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。</li><li><strong>使用 extern 时，对于没有初始化的变量，会把变量名指向一个之前定义过的存储位置。</strong></li><li>当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用extern 来得到已定义的变量或函数的引用。</li><li>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数</li></ul><p>main.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int count ;</span><br><span class="line">extern void write_extern();</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   count = 4;</span><br><span class="line">   write_extern();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>support.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">extern int count;</span><br><span class="line">void write_extern(void)</span><br><span class="line">&#123;</span><br><span class="line">   std::cout &lt;&lt; &quot;Count is &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>thread_local存储类：<strong>修饰的变量仅可在它在其上创建的线程上访问。</strong></li><li>变量在创建线程时创建，并在销毁线程时销毁。</li><li>每个线程都有其自己的变量副本。</li><li>thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</li></ul><h2 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C++ 运算符"></a>C++ 运算符</h2><ul><li>&amp; ：指针运算符，返回变量的地址。</li><li>* ：指针运算符，指向一个变量。</li></ul><h1 id="C-函数调用形式"><a href="#C-函数调用形式" class="headerlink" title="C++函数调用形式"></a>C++函数调用形式</h1><table><thead><tr><th>调用类型</th><th>描述</th></tr></thead><tbody><tr><td>传值调用</td><td>把参数的实际值复制给函数的形式参数<br/>在这种情况下，修改函数内的形式参数对实际参数没有影响</td></tr><tr><td><strong>指针调用</strong></td><td>把参数的地址复制给形式参数<br/>在函数内，该地址用于访问调用中要用到的实际参数<br/>这意味着，修改形式参数会影响实际参数</td></tr><tr><td><strong>引用调用</strong></td><td>把参数的引用复制给形式参数<br/>在函数内，该引用用于访问调用中要用到的实际参数<br/>这意味着，修改形式参数会影响实际参数</td></tr></tbody></table><ul><li>默认情况下，C++ 使用 传值调用 来传递参数，这意味着函数内的代码不能改变用于调用函数的参数</li></ul><h2 id="C-Lambda函数"><a href="#C-Lambda函数" class="headerlink" title="C++　Lambda函数"></a>C++　Lambda函数</h2><p>未看</p><h1 id="C-数组"><a href="#C-数组" class="headerlink" title="C++ 数组"></a>C++ 数组</h1><ol><li><p>初始化：</p><blockquote><p>/*第一种：逐个初始化数组*/<br>double arr[3];<br>arr[0]=1;<br>arr[1]=2;<br>arr[2]=3;<br>/*第二种：声明的同时使用｛｝初始化数组*/<br>double arr[]={1,2,3}; //或 double arr[3]={1,2,3};</p></blockquote></li><li><p>多维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//二维数组的初始化</span><br><span class="line">int a[3][4] = &#123;  </span><br><span class="line"> &#123;0, 1, 2, 3&#125; ,   /*  初始化索引号为 0 的行 */</span><br><span class="line"> &#123;4, 5, 6, 7&#125; ,   /*  初始化索引号为 1 的行 */</span><br><span class="line"> &#123;8, 9, 10, 11&#125;   /*  初始化索引号为 2 的行 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>传递数组给函数（三种形式）</p></li></ol><ul><li><p>形式参数是一个指针：</p><blockquote><p>void myFunction(int * parm){}</p></blockquote></li><li><p>形式参数是一个已定义大小的数组：</p><blockquote><p>void myFunction(int parm[10]){}</p></blockquote></li><li><p>形式参数是一个未定义大小的数组：</p><blockquote><p>void myFunction(int []parm){}</p></blockquote></li></ul><p>*<em>这三种声明方式的结果是一样的，因为每种方式都会告诉编译器将要接收一个整型指针 *</em></p><ol start="4"><li>函数返回数组</li></ol><ul><li><p>C++不允许函数返回一个完整的数组 比如：int [] myFunction(){}是错误的</p></li><li><p>但是可以指定不带索引的数组名来返回一个指向数组的指针，</p><blockquote><p>void * myFunction(){} //正确</p></blockquote></li><li><p>C++不支持在函数外返回局部变量的地址，除非局部变量是static变量<br>例如：int * myFunction(){<br>  int arr[] myarr;<br>  return myarr; // 错误，不能返回局部变量<br>}</p><blockquote><p>int * myFunction(){<br>   static int arr[] myarr;<br>   return myarr; // 可以，因为是静态局部变量<br>}</p></blockquote></li><li><p>*得到的是对应地址的值，&amp; 得到的是相应的地址</p></li></ul><figure class="image-box">                <img src="test4.png" alt="[sorry,图片挂了]" title="[程序截图]" class="[samll]">                <p>[程序截图]</p>            </figure><figure class="image-box">                <img src="test5.png" alt="[sorry,图片挂了]" title="[程序截图]" class="[samll]">                <p>[程序截图]</p>            </figure><h1 id="C-指针"><a href="#C-指针" class="headerlink" title="C++ 指针"></a>C++ 指针</h1><ul><li>变量是对程序中数据存储空间的一种抽象</li><li>内存中的每个字节都有一个编号——地址</li><li><em>取地址符&amp;*</em><br>取地址符&amp;获得一个变量的内存地址</li></ul><p><strong>解地址符*</strong><br>解地址符*获得一个内存地址保存的值</p><ul><li>指针是一个变量，其值为<strong>另一个变量的地址</strong>，即：内存位置的直接地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int    *ip;    /* 一个整型的指针 */</span><br><span class="line">double *dp;    /* 一个 double 型的指针 */</span><br><span class="line">float  *fp;    /* 一个浮点型的指针 */</span><br><span class="line">char   *ch;    /* 一个字符型的指针 */</span><br></pre></td></tr></table></figure><ul><li>所有指针的值的实际数据类型都是一样的，都是一个代表内存地址的长的16进制数 </li><li>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同</li></ul><p>C++中指针的五种操作 </p><ul><li>1.定义一个指针变量*<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *ptr_a;</span><br></pre></td></tr></table></figure></li><li>2.把变量地址赋给指针，使用取地址符*<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pi = 3.1415926;</span><br><span class="line">int *ptr_pi = &amp;pi; //这里的*是声明指针并不是取解地址符</span><br></pre></td></tr></table></figure></li><li>3.访问指针变量中可用地址的值，使用解地址符*<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pi = 3.1415926;</span><br><span class="line">int *ptr_pi = &amp;pi;</span><br><span class="line">std::cout &lt;&lt; *ptr_pi;</span><br></pre></td></tr></table></figure></li><li>4.简单的自增自减和加法减法运算符<br>因为指针保存的是变量的地址，而变量的地址是十六进制整形，所以也支持四种操作，而且只支持这四种</li><li>5.简单的比较两个指针的大小,可以使用三个比较运算符 ==、&lt; 和 &gt;<br>这三个比较运算符用于比较指针指向的内存地址是否相等，是否大于或小于</li></ul><h1 id="C-编程范例"><a href="#C-编程范例" class="headerlink" title="C++编程范例"></a>C++编程范例</h1><ul><li><ol><li>NULL空指针<br>声明指针变量的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯</li></ol></li></ul><ul><li>2.指针VS数组<br>C++ 中的指针和数组是密切相关的，指针和数组在很多情况下是可以互换的<br>一个指向数组开头的指针，可以通过使用指针的算术运算或数组索引来访问数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> #include  &lt;iostream&gt;</span><br><span class="line">  const int LEN=5;</span><br><span class="line"> int main()&#123;</span><br><span class="line">int arr[LEN]=&#123;8,16,32,64,128&#125;;</span><br><span class="line">//定义指针指向数组地址</span><br><span class="line">int *ptr=arr;</span><br><span class="line">//还可以将上一行代替为：int *ptr;   ptr=arr;</span><br><span class="line">for(int i=0;i&lt;LEN;i++)&#123;</span><br><span class="line">std::cout  &lt;&lt; &quot;arr[&quot; &lt;&lt; i &lt;&lt; &quot;]的内存地址为 &quot;;</span><br><span class="line">    std::cout &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;var[&quot; &lt;&lt; i &lt;&lt; &quot;] 的值为 &quot;;</span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    // 移动到下一个位置</span><br><span class="line">    ptr++;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>但是<br>指针和数组并不是完全互换的，就是数组变量是不能做自增自减和加减法赋值给自己<br>    int  arr[LEN] = {8, 16, 32,64,128};<br>    for (int i = 0; i &lt; MAX; i++)<br>    {<br>        *arr = i;    // 这是正确的语法<br>        arr++;       // 这是不正确的<br>    }<br>//即：数组名可以指向数组第一个元素地址，可以当作指针使用<br>//但是不能够改变数组名指向数组第一元素的事实    </p><ul><li><p>3.指针数组</p></li><li><p><em>C++ 中 数组名是一个指向数组中第一个元素的常量指针*</em><br>即：</p><blockquote><p>double balance[50];<br>balance是一个指向&amp;balance[0]的指针，即数组 balance 的第一个元素的地址<br>因此：*(balance + 4) 是一种访问 balance[4] 数据的合法方式</p></blockquote></li><li><p>4.C++指向指针的指针（多级间接寻址）<br>指向指针的指针，就是一个指针指向的地址保存的是另一个指针的地址，另一个指针保存的才是实际值的位置</p></li></ul><figure class="image-box">                <img src="test6.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure><blockquote><p>int **var;//多级间接寻址</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">double i=3;</span><br><span class="line">double *p_i=&amp;i;</span><br><span class="line">double **pp_i=&amp;p_i;</span><br></pre></td></tr></table></figure><h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><h2 id="引用-amp"><a href="#引用-amp" class="headerlink" title="引用&amp;"></a>引用&amp;</h2><p>引用 针对的是变量，这个要和 typedef 针对类型区分开来<br>可以在数据类型和变量名之间加上一个 &amp; 符号来声明一个引用，就像下面这样</p><blockquote><p>int a=8;<br>int &amp;b=a;//正确，需要区别等式的左值和右值<br>这里&amp;是在左值，不能看作是取地址符，而是声明引用的一种格式<br>&amp;出现在右值时才是取地址符</p></blockquote><p>不能直接指向数据<br>  int &amp;b=8；//错误</p><h3 id="指针和引用的区别："><a href="#指针和引用的区别：" class="headerlink" title="指针和引用的区别："></a>指针和引用的区别：</h3><p>1.引用必须在创建时被初始化。指针可以在任何时间被初始化<br>    int &b; // 错误<br>2.不存在空引用。引用必须连接到一块合法的内存，也就是不能有如下的声明<br>    int &amp;c = NULL;   // 错误</p><h2 id="引用的使用"><a href="#引用的使用" class="headerlink" title="引用的使用"></a>引用的使用</h2><h3 id="引用作为参数"><a href="#引用作为参数" class="headerlink" title="引用作为参数"></a>引用作为参数</h3><p>引用可以像指针一样作为函数的参数，使用方式和指针一模一样<br>相比传一般的参数更加的安全</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> void swap(int &amp;a,int &amp;b)&#123;</span><br><span class="line">int temp=a;</span><br><span class="line">a=b;</span><br><span class="line">b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用作为返回值"><a href="#引用作为返回值" class="headerlink" title="引用作为返回值"></a>引用作为返回值</h3><p>函数也可以返回一个引用，方式与返回一个指针类似，<strong>通常的做法是使用引用替代指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> double nums[]=&#123;11.11, 12.58, 12.21, 25.25, 88.8&#125;;</span><br><span class="line"> double&amp; setNum(int i)&#123;</span><br><span class="line">return nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数返回一个引用时，返回的是一个指向返回值的隐式指针<br>因此，我们可以把返回引用的函数作为左值，例如</p><blockquote><p>setNum(1)=203.0;</p></blockquote><p>例如实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">double nums[] = &#123;11.11, 12.58, 12.21, 25.25, 88.8&#125;;</span><br><span class="line"> double&amp; setNums(int i)&#123;</span><br><span class="line">return nums[i]; </span><br><span class="line"> &#125;  </span><br><span class="line"> int main()&#123;</span><br><span class="line">setNums(1)=203.0;//改变引用的值</span><br><span class="line">std::cout&lt;&lt; setNums(1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：203.0</p><ul><li>通常传递的是形参的值或者地址的值。此时需要将形参的值拷贝（赋值）给实参，然后操纵实参。</li></ul><p>当把参数声明为引用时，传递的是形参本身。<br>此时不需要将形参的值拷贝（赋值）给实参，可以直接操纵形参。和指针类似。<br>如下代码，形参v是一个vec3类型对象的引用，所以函数体内可以直接操作v对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline vec3&amp; vec3::operator+=(const vec3&amp; v)&#123;</span><br><span class="line">e[0]=v.e[0];</span><br><span class="line">e[1]=v.e[1];</span><br><span class="line">e[2]=v.e[2];</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.当返回一个引用时，被引用的对象不能超出作用域<br>返回一个对局部变量的引用是不合法的。<br>int&amp; func() {<br>   int q;<br>   return q;  // 在编译时发生错误<br>}</p><p>2.可以返回一个对静态变量的引用<br>int&amp; func() {<br>   static int x;<br>   return x;     // 安全，x 在函数作用域外依然是有效的<br>}</p><p>3.引用必须被初始化，不允许空引用，且引用一旦初始化后就不能引用其他数据</p><h2 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h2><p>引用能干的事情，指针都能干<br>那么问题来了，为什么还要“引用”这东西？<br>网友给出一个非常好的解释：（够用，简单，可靠）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    答案是“用适当的工具做恰如其分的工作”。</span><br><span class="line">    指针能够毫无约束地操作内存中的如何东西，尽管指针功能强大，但是非常危险。</span><br><span class="line">    就象一把刀，它可以用来砍树、裁纸、修指甲、理发等等，谁敢这样用？</span><br><span class="line">如果的确只需要借用一下某个对象的“别名”，那么就用“引用”，而不要用“指针”，以免发生意外。比如说，某人需要一份证明，本来在文件上盖上公章的印子就行了，如果把取公章的钥匙交给他，那么他就获得了不该有的权利。</span><br></pre></td></tr></table></figure><h1 id="Some-Tips"><a href="#Some-Tips" class="headerlink" title="Some Tips"></a>Some Tips</h1><h2 id="使用-ifdef和-pragam-once两种方式避免一个文件被include多次"><a href="#使用-ifdef和-pragam-once两种方式避免一个文件被include多次" class="headerlink" title="使用#ifdef和#pragam once两种方式避免一个文件被include多次"></a>使用#ifdef和#pragam once两种方式避免一个文件被include多次</h2><p><em>(不要拼措了，是pragam，不是program)</em></p><p>#ifdef受到C/C++语言标准支持，不会受到编译器的限制，而#pragma once一般由编译器提供保证。<br>#pragma once 的兼容性不如#if def</p><h2 id="定义类结构时，需要显式public参数或方法"><a href="#定义类结构时，需要显式public参数或方法" class="headerlink" title="定义类结构时，需要显式public参数或方法"></a>定义类结构时，需要显式public参数或方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class vec3&#123;</span><br><span class="line">public:</span><br><span class="line">float e[3];</span><br><span class="line"></span><br><span class="line">vec3()&#123;&#125;</span><br><span class="line">vec3(float e1, float e2,float e3)&#123;</span><br><span class="line">e[0] = e1;</span><br><span class="line">e[1] = e2;</span><br><span class="line">e[2] = e3;</span><br><span class="line">&#125;</span><br><span class="line">inline float r()&#123;</span><br><span class="line">return e[0];</span><br><span class="line">&#125;</span><br><span class="line">inline float g()&#123;</span><br><span class="line">return e[1];</span><br><span class="line">&#125;</span><br><span class="line">inline float b()&#123;</span><br><span class="line">return e[2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dot-A-B"><a href="#dot-A-B" class="headerlink" title="dot(A ,B)"></a>dot(A ,B)</h2><p>可以进行点乘运算  </p><h2 id="基本运算函数"><a href="#基本运算函数" class="headerlink" title="基本运算函数"></a>基本运算函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pow(a，b)幂运算</span><br><span class="line">sqrt(a)开平方根</span><br><span class="line">abs(a)整数求绝对值</span><br><span class="line">fabs(a)浮点数求绝对值</span><br></pre></td></tr></table></figure><h2 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h2><blockquote><p>class derived-class  :  access-specifier base-class<br>//derived-class 派生类   base-class 基类  access-specifer 访问修饰符（private ,public, &gt;protected）<br>eg   class Dustman: public Worker</p><ul><li><strong>如果没有使用访问修饰符，那么默认为private</strong> </li></ul></blockquote><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。<br>纯虚函数没有函数体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class shape&#123;</span><br><span class="line"> public:</span><br><span class="line">  virtual double calcPerimeter()=0//纯虚函数</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>不可实例化含有虚函数的基类</p><ul><li>引入原因</li></ul><p>1.在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。<br>2.为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。</p><p>特别注意：子类对虚函数的实现要放在.cpp中（不能放在.h中）</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li>抽象类无法实例化对象</li><li>包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。</li><li>存在纯虚函数是成为抽象类的充要条件。</li></ul><h2 id="rand-函数"><a href="#rand-函数" class="headerlink" title="rand()函数"></a>rand()函数</h2><ul><li>rand()不需要参数，它会返回一个从0到最大随机数的任意整数，</li><li>如果你要产生一个0~99这100个整数的一个随机整数，可以表达为:<blockquote><p>int num=rand()%100;</p></blockquote></li><li>如果要产生一个1~100这100个整数的一个随机整数，可以表达为：<blockquote><p>int num=rand()%100+1;</p></blockquote></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Basic&quot;&gt;&lt;a href=&quot;#Basic&quot; class=&quot;headerlink&quot; title=&quot;Basic&quot;&gt;&lt;/a&gt;Basic&lt;/h1&gt;&lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;
      
    
    </summary>
    
    
      <category term="Computer-Science" scheme="http://yoursite.com/categories/Computer-Science/"/>
    
      <category term="Programming Language" scheme="http://yoursite.com/categories/Computer-Science/Programming-Language/"/>
    
    
      <category term="Programming Language" scheme="http://yoursite.com/tags/Programming-Language/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习（二）</title>
    <link href="http://yoursite.com/2019/11/05/C++_Learning_2/"/>
    <id>http://yoursite.com/2019/11/05/C++_Learning_2/</id>
    <published>2019-11-05T01:56:27.000Z</published>
    <updated>2019-11-11T05:18:01.290Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：CSDN 图形跟班 相关博客</p><h1 id="C-重载操作符operator"><a href="#C-重载操作符operator" class="headerlink" title="C++重载操作符operator"></a>C++重载操作符operator</h1><h2 id="what："><a href="#what：" class="headerlink" title="what："></a>what：</h2><p>C++中的一个关键字，和运算符（例如=）一起使用，表示一个运算符重载函数，使扩展后的运算符的使用方法与重载前一致。</p><h2 id="why"><a href="#why" class="headerlink" title="why:"></a>why:</h2><p>C++提供的所有运算符只能支持对于基本数据类型以及标准库中提供的类的操作，而对于用户自己定义的类，如果想要通过操作符进行一些基本操作（比如：大小比较，相等判断等），需要用户自己定义操作符的具体实现。</p><h2 id="how-两种方式："><a href="#how-两种方式：" class="headerlink" title="how:两种方式："></a>how:两种方式：</h2><h3 id="将操作符重载实现为类的成员函数"><a href="#将操作符重载实现为类的成员函数" class="headerlink" title="将操作符重载实现为类的成员函数"></a>将操作符重载实现为类的成员函数</h3><p><strong>在类体中声明需要重载的操作符时，声明方式跟普通的成员函数一样</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//类结构中被声明的函数</span><br><span class="line"> bool operator==(const person&amp; ps) //person为自己定义的类</span><br><span class="line"> ｛</span><br><span class="line"> If（this-&gt;age == ps.age）&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line"> ｝</span><br></pre></td></tr></table></figure><h3 id="将操作符重载为非类的成员函数（即：全局函数）"><a href="#将操作符重载为非类的成员函数（即：全局函数）" class="headerlink" title="将操作符重载为非类的成员函数（即：全局函数）"></a>将操作符重载为非类的成员函数（即：全局函数）</h3><p>** 对于全局重载操作符，代表左操作数的参数必须被显式指定  **<br>即必须指明A==B中A的取值，而不能直接使用this关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//全局函数</span><br><span class="line">bool operator==(person const &amp; p1,person const &amp; p2);</span><br><span class="line">&#123;</span><br><span class="line">if(p1.age==p2.age)&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>‘ 其中person的定义如下：’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class person&#123;</span><br><span class="line">public :</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="C-中修饰符-inline-表示内联函数"><a href="#C-中修饰符-inline-表示内联函数" class="headerlink" title="C++中修饰符 inline,表示内联函数"></a>C++中修饰符 inline,表示内联函数</h1><h2 id="what"><a href="#what" class="headerlink" title="what:"></a>what:</h2><p>修饰为内联函数</p><h2 id="why-1"><a href="#why-1" class="headerlink" title="why:"></a>why:</h2><p>为了解决<strong>频繁调用</strong>的小函数大量消耗栈空间的问题<br>（栈空间：放置程序的局部数据的内存空间）<br>避免频繁调用函数对栈空间重复开辟所带来的消耗</p><h2 id="how"><a href="#how" class="headerlink" title="how:"></a>how:</h2><figure class="image-box">                <img src="wps1.jpg" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure><p>inline使用限制：inline修饰的函数只适合于函数内部简单，没有包含复杂的逻辑结构，例如：while,switch，同时inline修饰的函数还不能自己调用自己。 </p><p>建议inline函数的定义放置于头文件中</p><p>定义在类中的函数都是默认内联的，如果需要将类中的方法写于类结构之外，而又想为内联函数，则需要显式声明为inline</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//定义于类结构之内的函数默认为内联函数</span><br><span class="line">void Foo(int x,int y)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果需要定义于类结构之外的内联函数</span><br><span class="line">inline void  A::Foo(int x,int y)&#123;&#125;</span><br><span class="line">//同时需要注意的是，inline必须于函数定义放置一起</span><br></pre></td></tr></table></figure><hr><h1 id="C-头文件和实现函数分别写什么："><a href="#C-头文件和实现函数分别写什么：" class="headerlink" title="C++头文件和实现函数分别写什么："></a>C++头文件和实现函数分别写什么：</h1><h2 id="概览："><a href="#概览：" class="headerlink" title="概览："></a>概览：</h2><figure class="image-box">                <img src="image-20191110133905131.png" alt="[sorry,图片挂了]" title="[图表]" class="[samll]">                <p>[图表]</p>            </figure><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>头文件的所有内容，都必须包含在<br>#ifndef {Filename}<br>#define {Filename}<br>//{Content of head file}<br>#endif<br><em>这样才能保证头文件被多个其他文件引用(include)时，内部的数据不会被多次定义而造成错误</em></p><h2 id="inline限定符"><a href="#inline限定符" class="headerlink" title="inline限定符"></a>inline限定符</h2><ul><li>在头文件中，可以对函数用inline限定符来告知编译器，这段函数非常的简单，可以直接嵌入到调用定义之处。</li><li>当然inline的函数并不一定会被编译器作为inline来实现，如果函数过于复杂，编译器也会拒绝inline。</li><li>因此简单说来，代码最好短到只有3-5行的才作为inline。有循环，分支，递归的函数都不要用做inline。</li><li>对于在类定义内定义实现的函数，编译器自动当做有inline请求（也是不一定inline的）。因此在下边，我把带有inline限定符的函数成员和写在类定义体内的函数成员统称为“要inline的函数成员”</li></ul><h2 id="非模版类型"><a href="#非模版类型" class="headerlink" title="非模版类型"></a>非模版类型</h2><h3 id="全局类型"><a href="#全局类型" class="headerlink" title="全局类型"></a>全局类型</h3><p>就像前面笼统的话讲的：声明写在.h文件。<br>对于函数来讲，没有实现体的函数，就相当于是声明；而对于数据类型（包括基本类型和自定义类型）来说，其声明就需要用extern来修饰。<br>然后在.cpp文件里定义、实现或初始化这些全局函数和全局变量。</p><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>对于自定义类型，包括类（class）和结构体（struct），它们的定义都是放在.h文件中。<br>函数成员：<br>函数成员无论是否带有static限定符，其申明都放在.h文件的类定义内部。<br>对于要inline的函数成员其定义放在.h文件；其他函数的实现都放在.cpp文件中。<br>数据成员：<br>数据成员的申明与定义都是放在.h文件的类定义内部。对于数据类型，关键问题是其初始化要放在什么地方进行。</p><ul><li>对于只含有static限定符的数据成员，它的初始化要放在.cpp文件中。因为它是所有类对象共有的，因此必须对它做合适的初始化。</li><li>对于只含有const限定符的数据成员，它的初始化只能在构造函数的初始化列表中完成。因为它是一经初始化就不能重新赋值，因此它也必须进行合适的初始化。</li><li>对于既含有static限定符，又含有const限定符的数据成员，它的初始化和定义同时进行。它也是必须进行合适的初始化</li><li>对于既没有static限定符，又没有const限定符的数据成员，它的值只针对本对象可以随意修改，因此我们并不在意它的初始化什么时候进行。</li></ul><h2 id="模版类型"><a href="#模版类型" class="headerlink" title="模版类型"></a>模版类型</h2><p>对于模板，最重要的一点，就是在定义它的时候，编译器并不会对它进行编译，因为它没有一个实体可用。<br>只有模板被具体化（specialization）之后（用在特定的类型上），编译器才会根据具体的类型对模板进行编译。所以定义模板的时候，会发现编译器基本不会报错<br>因为模板的这种特殊性，它并没有自己的准确定义，因此我们不能把它放在.cpp文件中，而要把他们全部放在.h文件中进行书写。这也是为了在模板具体化的时候，能够让编译器可以找到模板的所有定义在哪里，以便真正的定义方法。</p><hr><h1 id="4-C-中的const修饰符"><a href="#4-C-中的const修饰符" class="headerlink" title="4.C++中的const修饰符"></a>4.C++中的const修饰符</h1><h2 id="const-修饰函数"><a href="#const-修饰函数" class="headerlink" title="const 修饰函数"></a>const 修饰函数</h2><p>表明该函数<strong>不修改类对象</strong>（不改变对象的非const成员变量. 也不能调用类中任何非const成员函数）。<br>格式：<strong>关键字const被放在成员函数的参数表（即“()”）和函数体（即“{}”）之间。</strong></p><ul><li>如下代码，const修饰的是函数x()。表示该函数的函数体中的操作不会修改当前这个类的类对象。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline float x()const&#123;return e[0];&#125;</span><br></pre></td></tr></table></figure></li><li>又如如下代码，const修饰的是函数operator+()。表示该函数的函数体中的操作不会修改当前这个类的类对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline const vec3&amp; operator+()const&#123;return *this;&#125;</span><br></pre></td></tr></table></figure></li><li>另外，对于在类体之外定义的const成员函数，我们必须在它的定义和声明中同时指定关键字const。比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline float x() const; //declaration</span><br><span class="line">inline float x() const&#123; //definition </span><br><span class="line">return e[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const-修饰函数参数"><a href="#const-修饰函数参数" class="headerlink" title="const 修饰函数参数"></a>const 修饰函数参数</h2>表示函数体中不能修改参数的值（包括参数本身的值或者参数其中包含的值）。比如如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline vec3&amp; vec3::operator+=(const vec3 &amp;v)&#123;</span><br><span class="line">e[0]+=v.e[0];</span><br><span class="line">e[1]+=v.e[1];</span><br><span class="line">e[2]+=v.e[2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="const-修饰函数返回值"><a href="#const-修饰函数返回值" class="headerlink" title="const 修饰函数返回值"></a>const 修饰函数返回值</h2><ul><li>const修饰函数返回值：<br>其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1  .const int fun1()//函数返回的是值</span><br><span class="line">2.  const int* fun2()//函数返回的是指针，调用时:const int* pValue=fun2();</span><br><span class="line"></span><br><span class="line">3.  int* const fun3()</span><br><span class="line">//函数返回的是指针（不是值）：调用时 int* const pValue = fun3();</span><br><span class="line">//我们可以把fun3()看作成一个变量，即指针本身不可变。</span><br></pre></td></tr></table></figure></li></ul><p>结合《RayTracing in One-Weekend》的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline const vec3&amp; operator+()&#123;return *this;&#125;</span><br></pre></td></tr></table></figure><p>这个就属于上面第二种情况，即函数operator+()返回的是一个vec3类型的对象的指针/引用。此处const表示该指针所指向的vec3类型的对象不可变。 </p><h1 id="C-中this指针"><a href="#C-中this指针" class="headerlink" title="C++中this指针"></a>C++中this指针</h1><p>每个类成员函数都含有一个指向被调用对象的指针，这个指针被称为this指针。<br>this表示被调用对象的指针；<br>*this表示被调用对象本身；<br>例如如下代码中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline void Screen::home()&#123;</span><br><span class="line">this-&gt;cursor=0;</span><br><span class="line">&#125;</span><br><span class="line">//this表示被调用对象的指针</span><br><span class="line">//this-&gt;cursor表示被调用对象的成员变量cursor，此处对该成员变量赋值。</span><br></pre></td></tr></table></figure><p>又如之前多次引用的《RayTracing-OneWeekend》中的code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline vec3&amp; vec3::operator+=(const vec3&amp;v)&#123;</span><br><span class="line">e[0]=v.e[0];</span><br><span class="line">e[1]=v.e[1];</span><br><span class="line">e[2]=v.e[2];</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于函数定义的函数返回是引用类型，即返回的不是值或者指针，而是对象本身。所以，此处需要return *this来返回对象本身，而不是return this（返回的是指针）。</p><h1 id="C-中使用初始化列表的构造函数"><a href="#C-中使用初始化列表的构造函数" class="headerlink" title="C++中使用初始化列表的构造函数"></a>C++中使用初始化列表的构造函数</h1><h2 id="代码实例："><a href="#代码实例：" class="headerlink" title="代码实例："></a>代码实例：</h2><p>结合《RayTracing One Weekend》中代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class sphere:public hitable&#123;</span><br><span class="line">public:</span><br><span class="line">sphere()&#123;&#125;</span><br><span class="line">//使用初始化列表的构造函数</span><br><span class="line">sphere(vec3 cen,float r):center(cen),radius(r)&#123;&#125;</span><br><span class="line">virtual bool hit(const ray&amp;r,float tmin,float tmax,hit_record &amp;rec)const;</span><br><span class="line">vec3 center;</span><br><span class="line">float radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><p>构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式。<br>上面这条语句做的事情是：将center初始化为cen；将radius初始化为r。特别注意这里是初始化，<br>不是赋值，<br>不是赋值，<br>不是赋值。</p><p>其等效的使用函数体的构造函数是：（函数体中是赋值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sphere(vec3 cen,float r)&#123;</span><br><span class="line">center=cen;</span><br><span class="line">radius=r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与使用函数体的构造函数区别"><a href="#与使用函数体的构造函数区别" class="headerlink" title="与使用函数体的构造函数区别"></a>与使用函数体的构造函数区别</h2><p>根本区别可以归结于“初始化”和“赋值”的区别<br>其一，“赋值”是属于计算。所以，时序上，初始化早于赋值<br>其二，有些类型的变量是只能初始化，不能赋值的。比如 const和引用。</p><p>构造函数可以分两个阶段进行：（1）初始化阶段；（2）普通计算阶段。</p><p>构造函数初始化列表是对类的成员做初始化，而在构造函数体内只是对类的数据成员进行了一次赋值操作。</p><p>因此我们需要注意的是：<br>一、若类的数据成员是const和引用类型，必须用初始化列表。<br>const的数据成员只能初始化而不能赋值，同样引用类型也是只可以被初始化，那么只有用初始化列表。<br>二、构造函数体内赋值会带来额外的开销，效率会低于构造函数初始化列表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料：CSDN 图形跟班 相关博客&lt;/p&gt;
&lt;h1 id=&quot;C-重载操作符operator&quot;&gt;&lt;a href=&quot;#C-重载操作符operator&quot; class=&quot;headerlink&quot; title=&quot;C++重载操作符operator&quot;&gt;&lt;/a&gt;C++重载操作符opera
      
    
    </summary>
    
    
      <category term="Computer-Science" scheme="http://yoursite.com/categories/Computer-Science/"/>
    
      <category term="Programming Language" scheme="http://yoursite.com/categories/Computer-Science/Programming-Language/"/>
    
    
      <category term="Programming Language" scheme="http://yoursite.com/tags/Programming-Language/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>RayTracing In One Weekend（一）</title>
    <link href="http://yoursite.com/2019/11/05/RayTracing_OneWeekend_1/"/>
    <id>http://yoursite.com/2019/11/05/RayTracing_OneWeekend_1/</id>
    <published>2019-11-05T01:56:27.000Z</published>
    <updated>2019-11-12T08:09:39.761Z</updated>
    
    <content type="html"><![CDATA[<p>实验室师兄师姐和RayTracing相关各路大佬都推荐入门《RayTracing in One Weekend》这本小册子<br>自然有这本书的独到之处<br>…其实学完了以后还有《RayTracing the Next Weekend》《RayTracing the future》<br>总之加油，冲冲冲<br>本博文参考了CSDN大佬图形跟班的很多内容，加入了部分自己的理解，不喜勿喷</p><hr><h1 id="vec3类解读"><a href="#vec3类解读" class="headerlink" title="vec3类解读"></a>vec3类解读</h1><h2 id="类体内"><a href="#类体内" class="headerlink" title="类体内"></a>类体内</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline float x()const&#123;</span><br><span class="line">return e[0]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类体内的函数x()</p><ul><li>const:表示该函数不修改类对象。</li><li>inline:表示该函数在程序中每个调用点上被内联展开。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline const vec3&amp; opearator+()const&#123;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类体内定义成员函数operator+()。</p><ul><li>operator+()：操作符重载。</li><li>&amp;：表示函数返回的是引用类型，此处表示返回的是一个vec3对象的引用。</li><li>const（左边这个）：表示函数返回不可被修改，此处表示返回的vec3对象的引用不可被修改。</li><li>const（右边这个）：表示该函数不修改类对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline vec3&amp; operator+=(const vec3&amp;v2);</span><br></pre></td></tr></table></figure><p>类体内声明成员函数operator+=()。</p><ul><li>&amp;（左边这个）：函数返回引用类型。当函数返回引用类型时，没有复制返回值。相反，返回的是对象本身。</li><li>&amp;（右边这个）：形参是引用类型。当把参数声明为引用时，传递的是形参本身。此时不需要将形参的值拷贝（赋值）给实参，可以直接操纵形参。和指针类似。</li></ul><h2 id="类体外："><a href="#类体外：" class="headerlink" title="类体外："></a>类体外：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline const vec3&amp; opearator+=(const vec3 &amp;v)&#123;</span><br><span class="line">e[0]=v.e[0];</span><br><span class="line">e[1]=v.e[1];</span><br><span class="line">e[2]=v.e[2];</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类体外定义operator+=函数</p><ul><li>vec3::：表示类体外定义的operator+=()是vec3类的成员函数。“::”是域解析操作符。表示某个成员属于某个类，某个类的某个成员。</li><li>this：指向被调用对象的指针。</li><li>*this：由于函数定义的函数返回是引用类型，即返回的不是值或者指针，而是对象本身。所以，此处需要return *this来返回对象本身，而不是return this（返回的是指针）。</li></ul><hr><h1 id="如何通过RayTracing-画第一张图"><a href="#如何通过RayTracing-画第一张图" class="headerlink" title="如何通过RayTracing 画第一张图"></a>如何通过RayTracing 画第一张图</h1><h2 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h2><p>ray类(ray.h)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#ifndef RAY_H</span><br><span class="line">#define RAY_H</span><br><span class="line">#include &quot;vec3.h&quot;</span><br><span class="line">class ray&#123;</span><br><span class="line">    public:</span><br><span class="line">        ray() &#123;&#125;</span><br><span class="line">        ray(const vec3&amp; a, const vec3&amp; b) &#123; A = a; B = b; &#125;</span><br><span class="line">        vec3 orgin() const     &#123; return A; &#125;</span><br><span class="line">        vec3 direction() const &#123; return B; &#125;</span><br><span class="line">        vec3 point_at_parameter(float t) const &#123; return A + t*B; &#125;</span><br><span class="line">//已知t时，可以获得光线上该点的坐标（向量）</span><br><span class="line">        vec3 A;</span><br><span class="line">        vec3 B;</span><br><span class="line">&#125;;</span><br><span class="line">#endif // RAY_H</span><br></pre></td></tr></table></figure><p>ray类中其实主要是定义两个向量：<br>起点向量（坐标）A和方向向量B。<br>从ray的方程R(t)=A+t*B可以得知A，B两个向量即可决定一条光线。<br>main.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#define STB_IMAGE_IMPLEMENTATION</span><br><span class="line">#include &quot;stb_image.h&quot;</span><br><span class="line">#define STB_IMAGE_WRITE_IMPLEMENTATION</span><br><span class="line">#include &quot;stb_image_write.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;ray.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vec3 color(const ray&amp;r)&#123;</span><br><span class="line">//对方向向量进行标准化。</span><br><span class="line">vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line">//标准化之后的y值在[-1,1]中 y+1在[0,2]中0.5*(y+1)在[0,1]中</span><br><span class="line">float t = 0.5*(unit_direction.y() + 1.0);</span><br><span class="line">//linear-blend 线性混合</span><br><span class="line">//t=0时，color=vec3(1,1,1)，乘以255后对应的RGB为（255，255，255）</span><br><span class="line">//t=1时，color=vec3(0,0.4,0)，乘以255后对应的RGB为（0，102，0）</span><br><span class="line">//如上两个颜色分别对应着白色和深绿色</span><br><span class="line">//画面颜色=(1-t)*白色+ t*深绿色，即画面颜色为白色和深绿色（沿着Y方向）的线性插值的结果。</span><br><span class="line">//如果要换成X或者Z方向，将上面的.y()改成.x()或者.z()即可。若要换其他颜色，设置对应的RGB值即可。</span><br><span class="line">return (1.0 - t)*vec3(1.0, 1.0, 1.0)+t*vec3(0,0.4,0);//表征颜色的三维向量(rgb) (0,0.4,0)为深绿色</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int nx = 1980;</span><br><span class="line">int ny = 1080;</span><br><span class="line">int channel = 3;//RGB三通道</span><br><span class="line">//字符数组保存图像数据</span><br><span class="line">unsigned char *data = new unsigned char[nx*ny*channel];s</span><br><span class="line">//camera相关数据</span><br><span class="line">vec3 lower_left_corner(-2.0, -1.0, -1.0); // 左下角</span><br><span class="line">vec3 horizontal(4.0, 0.0, 0.0); // 横轴</span><br><span class="line">vec3 vertical(0.0, 2.0, 0.0); // 竖轴</span><br><span class="line">vec3 origin(0.0, 0.0, 0.0); // eye</span><br><span class="line">for (int j = ny - 1; j &gt;= 0; j--)&#123;</span><br><span class="line">for (int i = 0; i &lt; nx; i++)&#123;</span><br><span class="line">float u = float(i) / float(nx);</span><br><span class="line">float v = float(j) / float(ny);</span><br><span class="line">/*由画面中每个像素点在画面中的相对位置每个像素点对应的光线的方向向量从而确定画面的范围/大小。（完成第一步）*/</span><br><span class="line">ray r(origin, lower_left_corner + u*horizontal + v*vertical);</span><br><span class="line">//根据光线对每一个像素点上色。（完成第二步）</span><br><span class="line">vec3 col = color(r);</span><br><span class="line">//写入图像数据</span><br><span class="line">data[(ny - j - 1)*nx * 3 + 3 * i] = int(255 * col[0]);</span><br><span class="line">data[(ny - j - 1)*nx * 3 + 3 * i+1] = int(255 * col[1]);</span><br><span class="line">data[(ny - j - 1)*nx * 3 + 3 * i+2] = int(255 * col[2]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; (ny - j)/float(ny)*100.0f &lt;&lt; &quot;%\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">stbi_write_png(&quot;Render_Chapter3_test.png&quot;,nx,ny,channel,data,0);</span><br><span class="line">cout &lt;&lt; &quot;完成渲染&quot;;</span><br><span class="line">system(&quot;PAUSE&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原理分析："><a href="#原理分析：" class="headerlink" title="原理分析："></a>原理分析：</h2><p>光线起点（也就是eye或者camera）固定的情况下，光线的方向向量的变动范围即形成光线束。光线束即是eye或者camera看到画面。<br>也就意味着：方向向量的变动范围决定着所能看到画面的范围。<br>另外，光线中每个光子的频率（颜色）决定这画面的内容。</p><p>所以，如果我们要通过光线追踪来画图的话，只需要做两件事情：<br>第一步：<strong>确定光线的方向向量的活动范围函数，从而确定画面的范围、大小（一条光线对应这画面上的一个像素点）。</strong><br>第二步：<strong>对每一条光线（像素点）设置颜色，（高质量图的每个像素点上可能对应多个采样）从而确定画面上的内容。</strong></p><p>如下图，光线的起点为（0，0，0），要求在黑框内作图（即光线和黑框平面的交点落在黑框内）</p><figure class="image-box">                <img src="image-20191110203344058.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure><p>同时我们需要对相机和人眼进行设置：<br>camera.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//camera类构造函数中进行初始化</span><br><span class="line">lower_left_corner = vec3(-2.0, -1.0, -1.0); // 左下角</span><br><span class="line">horizontal = vec3(4.0, 0.0, 0.0); // 横轴</span><br><span class="line">vertical = vec3(0.0, 2.0, 0.0); // 竖轴</span><br><span class="line">origin = vec3(0.0, 0.0, 0.0); // eye</span><br></pre></td></tr></table></figure><p>由上图可得：交点坐标可以表示为向量：lower_left_corner + u<em>horizontal + v</em>vertical<br>故可以通过camera类中的get_ray函数（传入u,v）得到光线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ray get_ray(float u, float v) &#123; </span><br><span class="line">return ray(origin, lower_left_corner + u*horizontal + v*vertical); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于：<br>光线的方向向量=交点向量-起点向量<br>且起点为原点，所以方向向量=交点向量。<br>（而方向向量由u,v决定）<br><strong>每个交点的u，v的值即为该像素点在整个画面中的位置。</strong></p><h2 id="结果展示：（背景）"><a href="#结果展示：（背景）" class="headerlink" title="结果展示：（背景）"></a>结果展示：（背景）</h2><p>（白色、深绿色沿着Y轴线性插值）</p><figure class="image-box">                <img src="Render_Chapter3_test.png" alt="[sorry,图片挂了]" title="[结果展示]" class="[samll]">                <p>[结果展示]</p>            </figure><hr><h1 id="如何通过RayTracing画球"><a href="#如何通过RayTracing画球" class="headerlink" title="如何通过RayTracing画球"></a>如何通过RayTracing画球</h1><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>当然这个球是画在之前的背景图上。<br>通过画第一张图，已经直到画图有两个步骤：<br>其一，确定位置（范围、大小）；<br>其二，设置颜色。<br>画球也不例外。<br>第一步：确定球的位置。球上每个像素点的位置即为光线与球的交点，所有这些交点就组成了球。所以，<strong>问题转化为找光线和球的交点。</strong><br>第二步：设置球的颜色。即<strong>设置光线和球交点的颜色。</strong><br>（<em>一张图遍历像素点，逐个像素点画出来的。一个光线代表着一个像素点。此处和球有交点的光线对应的像素点就设置成球的颜色</em>）</p><h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p>我们已知球心为（a,b,c）的球的表达式可以表示为：<br>$$<br>(x-a)^{2} + (y-b)^{2} + (z-c)^{2}=R^{2}<br>$$<br>可知：满足下式的任意点P均在球的表面：<br>$$<br>|P-C|^{2}=R^{2}<br>$$<br>故射线p(t)与球C是否有交点的问题<br>转变为<br>$$<br>(x-a)^{2} + (y-b)^{2} + (z-c)^{2}=R^{2}是否有解<br>$$<br>结合判别式disriminant可知：<br>$$<br>\Delta大于0时有两个解，等于0时有一个解，小于0时无解，对应着2到0个顶点.<br>$$</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>main.cpp<br>遍历图片每一个piexl<br>确定范围和大小:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//遍历每个像素的for循环中</span><br><span class="line">ray r(origin, lower_left_corner + u*horizontal + v*vertical);</span><br></pre></td></tr></table></figure><p>确定颜色:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//ray r 返回的颜色值</span><br><span class="line">//三维向量col保存RGB三个通道的值 </span><br><span class="line">vec3 col = color(r);</span><br></pre></td></tr></table></figure><p>在main()中调用了color(const ray&amp;r)方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//通过ray返回的颜色，决定每个pixel的颜色值</span><br><span class="line">//if有交点，返回小球的颜色</span><br><span class="line">//else无交点，返回背景的颜色</span><br><span class="line">vec3 color(const ray &amp;r)&#123;</span><br><span class="line">if (hit_sphere(vec3(0, 0, -1), 0.5, r))&#123;</span><br><span class="line">return vec3(1, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line">vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line">//一种根据ray的方向向量的y轴进行线性混合的背景渲染</span><br><span class="line">float t = (0.5*unit_direction.y() + 1.0);</span><br><span class="line">return (1.0 - t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在color()中调用了hit_sphere(vec3 center,float radius,ray &amp;r)方法<br>根据判别式判断光线r与球C是否有交点</p><ul><li>如果有交点，返回交点颜色</li><li>如果没有交点，则返回背景色</li></ul><h2 id="结果展示：（背景-一个球）"><a href="#结果展示：（背景-一个球）" class="headerlink" title="结果展示：（背景+一个球）"></a>结果展示：（背景+一个球）</h2><p>（通过增加x,y两轴的采样像素个数，提高了图像的质量）</p><figure class="image-box">                <img src="Render_Chapter4_test.png" alt="[sorry,图片挂了]" title="[结果展示]" class="[samll]">                <p>[结果展示]</p>            </figure><hr><h1 id="Visualize-The-Normal-With-a-Color-Map"><a href="#Visualize-The-Normal-With-a-Color-Map" class="headerlink" title="Visualize The Normal With a Color Map"></a>Visualize The Normal With a Color Map</h1><p>如何可视化球的法向量<br>我们首先需要的是：此处的法向量需要转换为单位法向量（通过vec3中的unit_vector()方法）<br>光线R与球C的交点为P，其交点对应的参数为t,调用Ray中的point_at_parameter(t)方法得到交点P的坐标<br>我们通过：将交点P的坐标减去球心C的坐标，得到了球C的法向量<br>然后将单位法向量映射成Color Map<br>main.cpp中color(const ray &amp;r)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vec3 color(const ray&amp; r) &#123;</span><br><span class="line">// 如果 ray r 击中球体的话，返回交点的 t</span><br><span class="line">float t = hit_sphere(vec3(0, 0, -1), 0.5, r);</span><br><span class="line">if (t &gt; 0.0) &#123;</span><br><span class="line">// 计算交点处的法线，并把法线进行可视化</span><br><span class="line">vec3 N = unit_vector(r.point_at_parameter(t) - vec3(0, 0, -1)); // P - C</span><br><span class="line">return 0.5*vec3(N.x() + 1, N.y() + 1, N.z() + 1);</span><br><span class="line">&#125;</span><br><span class="line">// 否则，计算背景色并返回</span><br><span class="line">vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line">t = (0.5 * unit_direction.y() + 1.0);</span><br><span class="line">return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果展示：（背景-一个球）-1"><a href="#结果展示：（背景-一个球）-1" class="headerlink" title="结果展示：（背景+一个球）"></a>结果展示：（背景+一个球）</h2><p>//通过可视化法向量绘制球的颜色,即是交点处法向量的映射</p><figure class="image-box">                <img src="ch05-1.png" alt="[sorry,图片挂了]" title="[结果展示]" class="[samll]">                <p>[结果展示]</p>            </figure><hr><h1 id="如何通过RayTracing画多个球"><a href="#如何通过RayTracing画多个球" class="headerlink" title="如何通过RayTracing画多个球"></a>如何通过RayTracing画多个球</h1><h2 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h2><p>画多个球方式和画一个球的方式是一样的<br>都是先找交点，再设置颜色<br><strong>第一步：求交，</strong>一条光线和N个球的交点可能有0-2N个。<br>之前画一个球时，我们取的是大于零的较小的那个根（因为只考虑球完全不透明）。<br>所以，现在画多个球，我们取所有交点中大于零最小的那个交点（因为我们向前看，只能看到最近的那个交点，后面所有的交点都被一个球体或者多个球体挡住了。）。<br><strong>第二步：设置颜色，</strong>这个和画一个球时一样，设置为球在该点的单位法向量的色彩表映射值。<br>这样的话，有个问题：球和球的相交边界处，两个球的颜色会不会很接近导致边界模糊呢？不会-不会-不会。<br>因为，虽然交点坐标非常接近，但是球的法向量是等于交点坐标减去球心坐标。从而，每个球在边界点的法向量是不一样的。如果两个球的球心坐标相差较大时，法向量坐标也会相差比较大，颜色也会相差比较大。</p><h2 id="代码分析：-1"><a href="#代码分析：-1" class="headerlink" title="代码分析："></a>代码分析：</h2><p>main.cpp中：<br>1.创建场景world<br><strong>场景中包含了多个hitable实例（物体）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 场景相关</span><br><span class="line">hitable *list[2];</span><br><span class="line">list[0] = new sphere(vec3(0, 0, -1), 0.5);</span><br><span class="line">list[1] = new sphere(vec3(0, -100.5, -1), 100);</span><br><span class="line">hitable *world = new hitable_list(list, 2);</span><br></pre></td></tr></table></figure><p>2.遍历图片每一个piexl<br>确定范围和大小:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//遍历每个像素的for循环中</span><br><span class="line">ray r(origin, lower_left_corner + u*horizontal + v*vertical);</span><br></pre></td></tr></table></figure><p>确定颜色:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 计算 ray r 射入场景 world 后，返回的颜色</span><br><span class="line">vec3 col = color(r, world);</span><br></pre></td></tr></table></figure><p>这其中main()中调用了color(const ray&amp;r,hitable *world)方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vec3 color(const ray&amp; r, hitable *world) &#123;</span><br><span class="line">hit_record rec;</span><br><span class="line">if (world-&gt;hit(r, 0.0, FLT_MAX, rec)) &#123;</span><br><span class="line">// 若 ray 交到场景中任意 object，计算其交点法线并可视化</span><br><span class="line">return 0.5*vec3(rec.normal.x() + 1, rec.normal.y() + 1, rec.normal.z() + 1);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// 否则，计算背景色并返回</span><br><span class="line">vec3 unit_direction = unit_vector(r.direction());//计算可得：交点向量=方向向量 </span><br><span class="line">float t = (0.5 * unit_direction.y() + 1.0);</span><br><span class="line">return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在color方法中<br>①使用hit_record（定义在hitable.h中的结构）记录交点信息<br>②if (world-&gt;hit(r, 0.0, FLT_MAX, rec))<br>world调用的是hitable_list中的hit方法，<br>在hitable_list中对于hit方法的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool hitable_list::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const &#123;</span><br><span class="line">hit_record temp_rec;</span><br><span class="line">bool hit_anything = false;</span><br><span class="line">/*如果光线撞上了球。N个球，可能有2N撞点，到底哪一个撞点是有效的呢？可以被最终设置颜色呢？原则是：找出最近的撞点。*/</span><br><span class="line">double closest_so_far = t_max;</span><br><span class="line">for (int i = 0; i &lt; list_size; i++) &#123;</span><br><span class="line">if (list[i]-&gt;hit(r, t_min, closest_so_far, temp_rec)) &#123;</span><br><span class="line">hit_anything = true;</span><br><span class="line">closest_so_far = temp_rec.t;</span><br><span class="line">rec = temp_rec;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return hit_anything;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，hitable_list的hit方法遍历了场景中的sphere对象(继承于hitable)，这些对象又调用了sphere中的hit方法<br>sphere.h中的hit方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool sphere::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const &#123;</span><br><span class="line">vec3 A_C = r.origin() - center;</span><br><span class="line">vec3 B = r.direction();</span><br><span class="line">float a = dot(B, B);</span><br><span class="line">float b = dot(A_C, B);</span><br><span class="line">float c = dot(A_C, A_C) - radius * radius;</span><br><span class="line">float discriminant = b * b - a * c;</span><br><span class="line">if (discriminant &gt; 0) &#123;</span><br><span class="line">float temp = (-b - sqrt(discriminant)) / a;</span><br><span class="line">if (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">rec.t = temp;</span><br><span class="line">rec.p = r.point_at_parameter(rec.t);</span><br><span class="line">rec.normal = (rec.p - center) / radius;</span><br><span class="line">//考虑光线交一个球时，优先取的是大于零的较小的那个根</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">temp = (-b + sqrt(discriminant)) / a;</span><br><span class="line">if (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">rec.t = temp;</span><br><span class="line">rec.p = r.point_at_parameter(rec.t);</span><br><span class="line">rec.normal = (rec.p - center) / radius;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于颜色设置的过程可以总结如下：<br>1，光线是否撞上球？是：设置为球的颜色；否：设置为背景颜色<br>2，如果光线撞上了球。N个球，可能有2N撞点，到底哪一个撞点是有效的呢？可以被最终设置颜色呢？原则是：找出最近的撞点。<br>3，怎么找？一个球一个球依次找。每个球可能有2个撞点，选出较近的有效的撞点。<br>4，然后，从所有这些每个球的较近的有效的撞点中，选出最近的那个撞点。<br>对应着hitable_list的循环中部分代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; list_size; i++) &#123;//遍历所有球</span><br><span class="line">if (list[i]-&gt;hit(r, t_min, closest_so_far, temp_rec)) &#123;//temp_rec中保存对于每个球而言，较小的t值</span><br><span class="line">hit_anything = true;</span><br><span class="line">closest_so_far = temp_rec.t;//更新变量t,选出最小t</span><br><span class="line">rec = temp_rec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果展示：（背景-两个球）"><a href="#结果展示：（背景-两个球）" class="headerlink" title="结果展示：（背景+两个球）"></a>结果展示：（背景+两个球）</h2><p>//此时需要考虑此处的交点为光线与所有球的所有交点中最近的那个交点</p><figure class="image-box">                <img src="Render_Chapter5_test.png" alt="[sorry,图片挂了]" title="[结果展示]" class="[samll]">                <p>[结果展示]</p>            </figure><hr><h1 id="如何对RayTracing图形消锯齿"><a href="#如何对RayTracing图形消锯齿" class="headerlink" title="如何对RayTracing图形消锯齿"></a>如何对RayTracing图形消锯齿</h1><h2 id="锯齿出现原因："><a href="#锯齿出现原因：" class="headerlink" title="锯齿出现原因："></a>锯齿出现原因：</h2><p>之前的图是每个像素点设置一个颜色值，相当于将像素中心位置的颜色设置给了整个像素。所以，如果两个像素点中心位置的颜色值相差比较大时，这两个像素点就会产生清晰的边界。</p><h2 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h2><p>增加采样精度<br>书上具体的做法是：<br>针对每个像素点随机采样100次，获得100个颜色值，然后将这100个颜色值的平均值设置为整个像素点的颜色值。<br>（在遍历每个像素的同时，增加对于每个像素的采样，nx,ny,ns三层循环）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 采样ns 次</span><br><span class="line">for (int k = 0; k &lt; ns; k++) &#123;</span><br><span class="line">float u = float(i + (rand() % 100 / float(100))) / float(nx);</span><br><span class="line">float v = float(j + (rand() % 100 / float(100)) )/ float(ny);</span><br><span class="line">// 确定 ray r</span><br><span class="line">ray r = cam.get_ray(u, v);</span><br><span class="line">// 累加 ray r 射入场景 world 后，返回的颜色</span><br><span class="line">col += color(r, world);</span><br><span class="line">&#125;</span><br><span class="line">col /= float(ns);//平均处理</span><br></pre></td></tr></table></figure><hr><h1 id="模拟RayTracing中漫反射材质（diffuse-material）"><a href="#模拟RayTracing中漫反射材质（diffuse-material）" class="headerlink" title="模拟RayTracing中漫反射材质（diffuse material）"></a>模拟RayTracing中漫反射材质（diffuse material）</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>前面画一个球时，球体的颜色设置为红色；<br>前面画多个球时，球体的颜色设置为球在该点的单位法向量的色彩表映射值；<br>现在需要画漫射材质的球，球体的颜色设置为背景颜色的系数倍。</p><p>首先，我们需要明晰：漫反射材质不自发光，只吸收和反射环境光（反射光的方向是随机的）<br>所以将漫射材料的球体的颜色设置为背景颜色乘以某系数是合理的。系数怎么确定呢？光线每被反射一次1/2（因为光线没被反射一次会被吸收一半）。</p><p>既然已经知道漫射材料球体的颜色和反射次数有关，那么怎么获得光线反射次数呢；<br>光线反射次数=光线撞击球的次数；<br>撞击次数由反射光线的方向和起点（前一个撞击点）决定；<br>第一撞击点，之前画一个球或者多个球都是根据撞击点画的；<br>现在问题归结于怎么获取反射光线的方向。<br>之前说了，漫射材质反射光线的方向是随机的，怎么模拟一个随机方向的向量呢？<br><strong>在交点处单位法向量的基础上加上一个长度小于1的随机向量。</strong></p><p>已知P为交点，PS为球C在P点的单位法向量，现在要模拟一个起点为P方向向球C外面的任何方向的向量。<br>流程：<br>1.找一个辅助球O，该球是球心在原点的单位球体；<br>2.在球O<strong>里面</strong>随机找一点E或者F；（E点在球体里面，也就是<strong>向量OE的长度小于1，PS为单位法向量</strong>）<br>3.OP+PS=OS，OS+OE=OM，OM-OP=PM。<br> 所以，<strong>PM</strong> =OP+PS+OE-OP=<strong>PS+OE。</strong><br>（辅助球O选球心在原点的单位球的原因，其一，“球心在原点”，方便计算；其二，“单位球”，可以确保PM的方向不会指向球C内部）。PS是已知的，所以只要获得OE即可。</p><figure class="image-box">                <img src="image-20191112082645320.png" alt="[sorry,图片挂了]" title="[原理图]" class="[samll]">                <p>[原理图]</p>            </figure><p>描述”起点在原点，长度小于1，方向随机“的向量采取‘’接受—拒绝’‘方式，<br>只接受部分区间的值<br>在这种方法中：<br>向量a  = (x, y, z)，b = (2x-1, 2y-1, 2z-1)， 其中x,y, z ∈（0，1）<br>推出2x-1, 2y-1, 2z-1∈（-1，1）推出(2x-1)2+(2y-1)2+(2z-1)2∈（0，3）推出|b|∈（0，  √3 ）<br>而我们能接受的是|b|∈（0，1），所以采取“接受——拒绝”方式：只接受|b|∈（0，1）。<br><strong>下面代码即是采用接拒法，描述”起点在原点，长度小于1，方向随机的向量“</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//在单位立方体中取一点S，让xyz随机取（-1,1）之间的值，S则在这个立方体内，若xyz的平方和小于1，则在球内</span><br><span class="line">vec3 random_in_unit_sphere()&#123;</span><br><span class="line">vec3 p;</span><br><span class="line">do &#123;</span><br><span class="line">p = 2.0f * vec3((rand() % 100 / float(100)), (rand() % 100 / float(100)), (rand() % 100 / float(100))) - vec3(1.0f, 1.0f, 1.0f);</span><br><span class="line">&#125; while (p.squared_length() &gt;= 1.0f);</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们又回顾一下整个流程：<br>1，起点为原点的光线撞击球C，获得撞击点P和单位法向量PS。<br>2，产生一个“起点在原点，长度小于1，方向随机”的向量OE。<br>3，OP+PS+OE-OP=PM，PM即为漫射材料的球体在P点的随机反射方向向量。<br>4，反射光线是以P为起点，PM为方向向量，所以，我们可以获得反射光线的方程<br>5，让反射光线去撞击其他球吧（回到第一步）</p><p>由此设置color方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">光线撞击球的次数=光线反射的次数*球体该像素点的颜色值对应背景颜色的系数值。</span><br><span class="line">//递归，同一条ray可能多次反射</span><br><span class="line">vec3 color(const ray&amp;r,hitable *world)&#123;</span><br><span class="line">hit_record rec;</span><br><span class="line">if (world-&gt;hit(r, 0.001, FLT_MAX, rec))&#123;</span><br><span class="line">vec3 target = rec.p + rec.normal + random_in_unit_sphere();</span><br><span class="line">return 0.5*color(ray(rec.p, target - rec.p), world);//0.5为吸收率</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line">float t = (0.5*unit_direction.y() + 1.0);</span><br><span class="line">return (1.0 - t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果展示：-背景-两个漫反射材质的球-、"><a href="#结果展示：-背景-两个漫反射材质的球-、" class="headerlink" title="结果展示：(背景+两个漫反射材质的球)、"></a>结果展示：(背景+两个漫反射材质的球)、</h2><p>Diffuse材质要在返回的基础上乘上吸收率<br>Tips:漫反射和镜面反射的区别在于，漫反射的每次反射方向是随机的。</p><figure class="image-box">                <img src="Render_Chapter7.png" alt="[sorry,图片挂了]" title="[结果展示]" class="[samll]">                <p>[结果展示]</p>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实验室师兄师姐和RayTracing相关各路大佬都推荐入门《RayTracing in One Weekend》这本小册子&lt;br&gt;自然有这本书的独到之处&lt;br&gt;…其实学完了以后还有《RayTracing the Next Weekend》《RayTracing the fu
      
    
    </summary>
    
    
      <category term="Computer-Science" scheme="http://yoursite.com/categories/Computer-Science/"/>
    
      <category term="RayTracing" scheme="http://yoursite.com/categories/Computer-Science/RayTracing/"/>
    
    
      <category term="RayTracing" scheme="http://yoursite.com/tags/RayTracing/"/>
    
  </entry>
  
  <entry>
    <title>RayTracing In One Weekend（二）</title>
    <link href="http://yoursite.com/2019/11/05/RayTracing_OneWeekend_2/"/>
    <id>http://yoursite.com/2019/11/05/RayTracing_OneWeekend_2/</id>
    <published>2019-11-05T01:56:27.000Z</published>
    <updated>2019-11-12T08:24:36.982Z</updated>
    
    <content type="html"><![CDATA[<p>接下来介绍《RayTracing In One Weekend》Chapter8 以后的内容<br>本博文参考了CSDN大佬图形跟班的很多内容，加入了部分自己的理解，不喜勿喷</p><hr><h1 id="如何模拟材质"><a href="#如何模拟材质" class="headerlink" title="如何模拟材质"></a>如何模拟材质</h1><p>前面章节，我们已经知道漫射材料颜色的设置：return 0.5*color( ray(rec.p, target-rec.p), world);也就是反射光线方向向量的映射值和衰减系数的乘积。</p><h2 id="材质Material"><a href="#材质Material" class="headerlink" title="材质Material"></a>材质Material</h2><p>根据不同的反射方式，可将材质分为漫反射材质和镜面反射材质。各种反射材质又有不同的反射衰减系数。所以，我们有必要先定义一个material的抽象类，这个类包含反射光线和衰减系数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MATERIAL_H</span><br><span class="line">#define MATERIAL_H</span><br><span class="line">#include &quot;hitable.h&quot;</span><br><span class="line">class material&#123;</span><br><span class="line">public:</span><br><span class="line">virtual bool scatter(const ray&amp;r,const hit_record&amp; rec,vec3 &amp;attenuation,ray &amp;scattered)const=0;</span><br><span class="line">&#125;;</span><br><span class="line">#endif // MATERIAL_H</span><br></pre></td></tr></table></figure><p>然后定义Lambertian材质和Metal材质,使这两个类继承于Material类<br>Lambertian：也叫理想散射，Lambertian表面是指在一个固定的照明分布下从所有的视场方向上观测都具有相同亮度的表面，Lambertian表面不吸收任何入射光．</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class lambertian:public material&#123;</span><br><span class="line">public:</span><br><span class="line">lambertian(const vec3&amp;a):albedo(a)&#123;&#125;</span><br><span class="line">virtual bool scatter(const ray&amp;r,const hit_record&amp;rec,vec3&amp; attenuation,ray &amp;scattered)const&#123;</span><br><span class="line">vec3 target=rec.p+rec.normal+random_in_unit_sphere();</span><br><span class="line">scattered=ray(rec.p,target-rec.p);</span><br><span class="line">attenuation=albedo;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">vec3 albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Metal材质（表面进行镜面反射）吸收所有折射的光照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class metal:public material&#123;</span><br><span class="line">public:</span><br><span class="line">metal(const vec3&amp;a,float f):albedo(a),fuzz(f)&#123;&#125;</span><br><span class="line">virtual bool scatter(const ray&amp;r,const hit_record &amp;rec,vec3&amp;attenuation,ray &amp;scattered)const&#123; </span><br><span class="line">vec3 reflected=reflect(unit_vector(r_in.direction()),rec.normal);</span><br><span class="line">scattered=ray(rec.p,reflected+fuzz*random_in_unit_sphere());</span><br><span class="line">attenuation=albedo;</span><br><span class="line">// 反射出的光线若与 normal 夹角大于90度，则不正确</span><br><span class="line">return (dot(scattered.direction(),rec.normal)&gt;0);</span><br><span class="line">&#125;;</span><br><span class="line">vec3 albedo;</span><br><span class="line">float fuzz;</span><br></pre></td></tr></table></figure><p>在metal材质中，对于镜面反射后反射光的方向向量的计算为函数reflect:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//镜面反射</span><br><span class="line">vec3 reflect(const vec3&amp; v, const vec3&amp; n) &#123;</span><br><span class="line">return v - 2 * dot(v, n)*n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="image-20191112103139971.png" alt="[sorry,图片挂了]" title="[反射推导]" class="[samll]">                <p>[反射推导]</p>            </figure><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>由于在此引入了material材质的概念，因此需要在过去代码的基础上进行修改：<br>1.修改hitable.h中定义的hitable_record结构（保存交点信息）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct hit_record &#123;</span><br><span class="line">float t;</span><br><span class="line">vec3 p;</span><br><span class="line">vec3 normal;</span><br><span class="line">//Chapter8中添加了材质指针 </span><br><span class="line">//当Ray击中一个表面时，结构体中的材质指针能够给出材质</span><br><span class="line">//通过color()方法得到hit_record结构 </span><br><span class="line">material *mat_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.同时需要更新sphere.h中的类结构定义，同时更新其构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class sphere :public hitable &#123;</span><br><span class="line">public:</span><br><span class="line">sphere() &#123;&#125;</span><br><span class="line">sphere(vec3 cen, float r, material *m) &#123; center = cen; radius = r; mat_ptr = m; &#125;</span><br><span class="line">virtual bool hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const;</span><br><span class="line">vec3 center;</span><br><span class="line">float radius;</span><br><span class="line">material *mat_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3.还需要修改color方法，基于不同的材质属性设置颜色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//此处的depth记录球撞击的次数</span><br><span class="line">//在if判断中设置depth的阈值，即最大撞击次数</span><br><span class="line">vec3 color(const ray&amp; r, hitable *world, int depth) &#123;</span><br><span class="line">hit_record rec;</span><br><span class="line">if (world-&gt;hit(r, 0.001, FLT_MAX, rec)) &#123;</span><br><span class="line">ray scattered;</span><br><span class="line">vec3 attenuation;</span><br><span class="line">if (depth &lt; 50 &amp;&amp; rec.mat_ptr-&gt;scatter(r, rec, attenuation, scattered)) &#123;</span><br><span class="line">return attenuation * color(scattered, world, depth + 1);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">return vec3(0, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// 否则，计算背景色并返回</span><br><span class="line">vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line">float t = (0.5 * unit_direction.y() + 1.0);</span><br><span class="line">return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.最后由于修改了sphere的构造函数，因此在main()实例化sphere对象时需要传入实例化的Materail对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list[0] = new sphere(vec3(0,0,-1), 0.5, new lambertian(vec3(0.8, 0.3,0.3)));</span><br><span class="line">list[1] = new sphere(vec3(0,-100.5,-1),100, new lambertian(vec3(0.8,0.8, 0.0)));</span><br><span class="line">list[2] = new sphere(vec3(1,0,-1), 0.5, new metal(vec3(0.8, 0.6, 0.2)));</span><br><span class="line">list[3] = new sphere(vec3(-1,0,-1), 0.5, new metal(vec3(0.8, 0.8,0.8)));</span><br><span class="line">hitable *world = new hitable_list(list, 4);</span><br></pre></td></tr></table></figure><h2 id="结果展示："><a href="#结果展示：" class="headerlink" title="结果展示："></a>结果展示：</h2><figure class="image-box">                <img src="Render_Chapter8.png" alt="[sorry,图片挂了]" title="[结果展示]" class="[samll]">                <p>[结果展示]</p>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接下来介绍《RayTracing In One Weekend》Chapter8 以后的内容&lt;br&gt;本博文参考了CSDN大佬图形跟班的很多内容，加入了部分自己的理解，不喜勿喷&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;如何模拟材质&quot;&gt;&lt;a href=&quot;#如何模拟材质&quot; class=
      
    
    </summary>
    
    
      <category term="Computer-Science" scheme="http://yoursite.com/categories/Computer-Science/"/>
    
      <category term="RayTracing" scheme="http://yoursite.com/categories/Computer-Science/RayTracing/"/>
    
    
      <category term="RayTracing" scheme="http://yoursite.com/tags/RayTracing/"/>
    
  </entry>
  
  <entry>
    <title>Matlab相关</title>
    <link href="http://yoursite.com/2019/11/05/Matlab_Learning/"/>
    <id>http://yoursite.com/2019/11/05/Matlab_Learning/</id>
    <published>2019-11-05T01:56:27.000Z</published>
    <updated>2019-11-05T03:11:54.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Matlab学习"><a href="#Matlab学习" class="headerlink" title="Matlab学习"></a>Matlab学习</h1><h3 id="1-dir-使用"><a href="#1-dir-使用" class="headerlink" title="1. dir()使用"></a>1. dir()使用</h3><p>dir函数可以有调用方式</p><ul><li><p>dir(‘.’) 列出当前目录下所有子文件夹和文件</p></li><li><p>dir(‘G:\Matlab’) 列出指定目录下所有子文件夹和文件</p></li><li><p>dir(‘*.m’) 列出当前目录下符合正则表达式的文件夹和文件</p></li><li><p>得到的为结构体数组每个元素都是如下形式的结构体</p><pre><code>name  -- filenamedate  -- modification datebytes  -- number of bytes allocated to the fileisdir  -- 1 if name is a directory and 0 if notdatenum -- modification date as a MATLAB serial date number</code></pre><p> 分别为文件名,修改日期,大小,是否为目录,Matlab特定的修改日期</p><p>可以提取出文件名以作读取和保存用.</p></li></ul><h3 id="2-exist-使用"><a href="#2-exist-使用" class="headerlink" title="2. exist()使用"></a>2. exist()使用</h3><ul><li>判断某个变量，函数，类，文件夹等参数是否存在。</li><li>A=exists(“name”,”kind”)，name可以是变量，函数，类，文件夹等</li><li>返回值的含义如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 不存在则返回值 </span><br><span class="line">1 name 可以是变量名，如果存在，返回值 </span><br><span class="line">2 函数名、m 文件名，存在则返回值 </span><br><span class="line">3 mex 文件、dll 文件，存在则返回值</span><br><span class="line">4 内嵌的函数，存在则返回值 5 p码文件 ， 存在则返回值 </span><br><span class="line">6 目录，存在则返回值 </span><br><span class="line">7 路径，存在则返回值 </span><br><span class="line">8 Java class，存在则返回值</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3. for循环"></a>3. for循环</h3><ul><li>for k=1:10  正序遍历</li><li>for k=10:-1:1 倒序遍历，从10到1，每次递减-1</li></ul><h3 id="4-strrep-使用"><a href="#4-strrep-使用" class="headerlink" title="4.strrep()使用"></a>4.strrep()使用</h3><ul><li>查找并替换函数</li><li>strrep(A,B,C); 在A中查找B并替换为C</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Matlab学习&quot;&gt;&lt;a href=&quot;#Matlab学习&quot; class=&quot;headerlink&quot; title=&quot;Matlab学习&quot;&gt;&lt;/a&gt;Matlab学习&lt;/h1&gt;&lt;h3 id=&quot;1-dir-使用&quot;&gt;&lt;a href=&quot;#1-dir-使用&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Computer-Science" scheme="http://yoursite.com/categories/Computer-Science/"/>
    
      <category term="Programming Language" scheme="http://yoursite.com/categories/Computer-Science/Programming-Language/"/>
    
    
      <category term="Programming Language" scheme="http://yoursite.com/tags/Programming-Language/"/>
    
  </entry>
  
  <entry>
    <title>全局光照（总览）</title>
    <link href="http://yoursite.com/2019/11/05/GI_1/"/>
    <id>http://yoursite.com/2019/11/05/GI_1/</id>
    <published>2019-11-05T01:56:27.000Z</published>
    <updated>2019-11-07T13:14:37.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul><li>全局光照，(Global Illumination,简称 GI), 或被称为Indirect Illumination, 间接光照，是指既考虑场景中直接来自光源的光照（Direct Light）又考虑经过场景中其他物体反射后的光照（Indirect Light）的一种渲染技术。使用全局光照能够有效地增强场景的真实感。</li></ul><p>即可以理解为：全局光照 = 直接光照(Direct Light) + 间接光照(Indirect Light)<br>下面是直接光照和全局光照的对比</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="1.jpg" alt="[sorry,图片挂了]" title="[直接光照]" class="justify-small">                <p>[直接光照]</p>            </figure><p>}</p><p>@card{</p><figure class="image-box">                <img src="2.jpg" alt="[sorry,图片挂了]" title="[全局光照]" class="justify-small">                <p>[全局光照]</p>            </figure><p>}</p><p>}</p><p><strong>全局光照技术历程</strong></p><ul><li><p>光线投射 Ray Casting<br>其具体思路是从每一个像素射出一条射线，然后找到最接近的物体挡住射线的路径，而视平面上每个像素的颜色取决于从可见光表面产生的亮度。</p></li><li><p>光线追踪 Ray Tracing<br>Turner Whitted在光线投射的基础上，加入光与物体表面的交互，让光线在物体表面沿着反射，折射以及散射方式上继续传播，直到与光源相交。<br>这一方法后来也被称为经典光线跟踪方法、递归式光线追踪（Recursive Ray Tracing）方法，或 Whitted-style 光线跟踪方法。</p></li><li><p>分布式光线追踪 Distributed Ray Tracing<br>Cook于1984年引入蒙特卡洛方法（Monte Carlo method）到光线跟踪领域，将经典的光线跟踪方法扩展为分布式光线跟踪算法，又称为随机光线追踪。<br>可以模拟更多的效果，如金属光泽、软阴影、景深（ Depthof Field）、运动模糊等等。</p></li><li><p>渲染方程 The Rendering Equation<br>Kajiya于1986年建立了渲染方程的相关理论，使用它来解释光能传输的产生的各种现象。这一方程描述了场景中光能传输达到稳定状态以后，物体表面某个点在某个方向上的辐射率（Radiance）与入射辐射亮度等的关系。<br>可以将渲染方程理解为全局光照算法的基础，随后出现的很多全局光照的算法，都是以渲染方程为基础，对其进行简化的求解，以达到优化性能的目的。渲染方程根据光的物理学原理，以及能量守恒定律，完美地描述了光能在场景中的传播。很多真实感渲染技术都是对它的一个近似。</p></li><li><p>路径追踪 Path Tracing<br>根据渲染方程， Kajiya 提出的路径追踪方法是第一个无偏（Unbiased）的渲染方法。<br>路径追踪的基本思想是从视点发出一条光线，光线与物体表面相交时根据表面的材质属性继续采样一个方向，发出另一条光线，如此迭代，直到光线打到光源上（或逃逸出场景），然后用蒙特卡洛的方法，计算其贡献，作为像素的颜色值。而使用蒙特卡洛方法对积分的求解是无偏的，只要时间足够长，最终图像能收敛到一个正确的结果。</p></li><li><p>双向路径追踪 Bidirectional Path Tracing<br>基本思想是同时从视点、光源打出射线，经过若干次反弹后，将视点子路径（ eye path） 和光源子路径（ light path） 上的顶点连接起来（连接时需要测试可见性），以快速产生很多路径。<br>这种方法能够产生一些传统路径追踪难以采样到的光路，所以能够很有效地降低噪声。<br>进一步的， [Veach 1997]将渲染方程改写成对路径积分的形式，允许多种路径采样的方法来求解该积分。</p></li><li><p>梅特波利斯光照传输 Metropolis Light Transport 简称MLT<br>路径追踪（ Path Tracing）中一个核心问题就是怎样去尽可能多的采样一些贡献大的路径，而该方法可以自适应的生成贡献大的路径，简单来说它会避开贡献小的路径，而在贡献大的路径附近做更多局部的探索，通过特殊的变异方法，生成一些新的路径，这些局部的路径的贡献往往也很高。<br>与双向路径追踪相比， MLT 更加鲁棒，能处理各种复杂的场景。<br>比如说整个场景只通过门缝透进来的间接光照亮，此时传统的路径追踪方法因为难以采样到透过门缝的这样的特殊路径而产生非常大的噪声。</p></li></ul><p><strong>回到光线追踪（Ray Tracing）上:</strong><br>上面我们说到Ray Tracing是三维计算机图形学中的特殊渲染方法，跟踪从眼睛发出的光线而不是光源发出的光线。<br>通过这样一项技术得到的结果有着更好的光线效果，例如对于反射和折射有着更准确的模拟效果，并且效率非常高，追求高质量图像时常采用这样的方式。<br>Ray Tracing的缺点就是性能，它所需要的计算量非常巨大。<br>传统的RayTracing并不一定是真实效果图像，只有在非常近似或者完全实现渲染方程时，才能实现真正的真实效果图像。由于渲染方程描述了每个光束的物理效果，所以实现渲染方程可以得到真正的真实效果，但是，考虑到所需要的计算资源，这通常是无法实现的。于是，所有可以实现的渲染模型都必须是渲染方程的近似，而光线跟踪就不一定是最为可行的方法。包括光子映射在内的一些方法，都是依据光线跟踪实现一部分算法，但是可以得到更好的效果。</p><p><strong>再讲到路径追踪（Path Tracing）上：</strong><br>简单来说，路径追踪 = 光线追踪+ 蒙特卡洛方法。</p><p><strong>我们再来总结一下Ray Casting，Ray Tracing，PathTracing这三者的区别</strong></p><ul><li>Ray Casting：其它就是ray tracing的第一步，发射光线，与物体相交。</li><li>Ray Tracing：这其实是个框架，而不是个方法。符合这个框架的都叫raytracing。这个框架就是从视点发射ray，与物体相交就根据规则反射、折射或吸收。遇到光源或者走太远就停住。一般来说运算量不小。</li><li>Path Tracing：是ray tracing + 蒙特卡洛法。在相交后会选一个随机方向继续跟踪，并根据BRDF计算颜色。运算量也不小。还有一些小分类，比如Bidirectional path tracing。</li></ul><p><strong>最后我们来学习一下AO</strong><br>AO是Ambient Occlusion的简称，是全局光照明的一种近似替代品，<br>可以产生重要的视觉明暗效果，通过描绘物体之间由于遮挡而产生的阴影， 能够更好地捕捉到场景中的细节，可以解决漏光，阴影漂浮等问题，改善场景中角落、锯齿、裂缝等细小物体阴影不清。<br>AO最常用的方法是SSAO，UE4中的AO即是采用这种方案</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1308281829&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;全局光照，(Global Illuminatio
      
    
    </summary>
    
    
      <category term="Computer-Science" scheme="http://yoursite.com/categories/Computer-Science/"/>
    
      <category term="RayTracing" scheme="http://yoursite.com/categories/Computer-Science/RayTracing/"/>
    
    
      <category term="RayTracing" scheme="http://yoursite.com/tags/RayTracing/"/>
    
  </entry>
  
  <entry>
    <title>PBRT（Chapter1）</title>
    <link href="http://yoursite.com/2019/11/05/PBRT_Learning_1/"/>
    <id>http://yoursite.com/2019/11/05/PBRT_Learning_1/</id>
    <published>2019-11-05T01:56:27.000Z</published>
    <updated>2019-11-07T12:39:54.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PBRT-CHAPTER-1"><a href="#PBRT-CHAPTER-1" class="headerlink" title="PBRT CHAPTER_1"></a>PBRT CHAPTER_1</h1><p>*Introduction<br>PBRT(Physically Based Rendering Toolkit)<br>基于物理渲染</p><p>渲染是根据三维场景的描述生成图像的过程。显然，这是一个非常广泛的任务，有许多方法可以实现它。基于物理的技术试图模拟现实;也就是说，他们使用物理原理来模拟光和物质的相互作用。虽然基于物理的方法似乎是处理呈现的最明显的方法，但它只是在过去10年左右的实践中才被广泛采用。<br>学习基于PBRT-v3<br>友情链接：<br>（一）PBRT-v3在线电子书：<a href="http://www.pbr-book.org/3ed-2018/contents.html" target="_blank" rel="noopener">http://www.pbr-book.org/3ed-2018/contents.html</a><br>（二）实验室学长的PBRT-v3配置教程: <a href="https://fancyvin.github.io/2019/07/13/how-to-compile-pbrt-v3-renderer/" target="_blank" rel="noopener">https://fancyvin.github.io/2019/07/13/how-to-compile-pbrt-v3-renderer/</a></p><h2 id="1-1-Literate-Programming-文学编程"><a href="#1-1-Literate-Programming-文学编程" class="headerlink" title="1.1 Literate Programming 文学编程"></a>1.1 Literate Programming 文学编程</h2><p>PBRT-v2和-v3之间的改动</p><ul><li>增加了一个功能完备的BRDF模型，支持体积光照与重要性多重路径采样。</li><li>次表面散射，基于光线追踪技术，无需预处理。</li><li>解决浮点数四折五入的问题</li><li>光子映射</li><li>样本生成</li></ul><h2 id="1-2-Photorealistic-Rendering-and-the-Ray-Tracing-Algorithm-照片级渲染及光线跟踪算法"><a href="#1-2-Photorealistic-Rendering-and-the-Ray-Tracing-Algorithm-照片级渲染及光线跟踪算法" class="headerlink" title="1.2 Photorealistic Rendering and the Ray-Tracing Algorithm 照片级渲染及光线跟踪算法"></a>1.2 Photorealistic Rendering and the Ray-Tracing Algorithm 照片级渲染及光线跟踪算法</h2><ul><li>渲染分块问题：<br>渲染任务过多的分块会影响性能。<br>过小分块也是不科学的，因为处理核心问题有一定的开销。<br>场景的复杂性会对不同CPU核心的渲染速度产生影响。所以如果是分块数等于核心数，渲染完的核心会等待没渲染完的核心。</li></ul><p>PBRT采用的是16*16的方案</p><p>浮点类型<br>pbrt采用了FLOAT，这样浮点格式会根据宏进行调整</p><h3 id="1-2-1-Camera相机"><a href="#1-2-1-Camera相机" class="headerlink" title="1.2.1 Camera相机"></a>1.2.1 Camera相机</h3><ul><li>针孔相机<br>  胶片Film    针孔Pinhole   视见体Viewing Volume<h3 id="1-2-2-Ray-Object-Intersection光线-对象相交"><a href="#1-2-2-Ray-Object-Intersection光线-对象相交" class="headerlink" title="1.2.2 Ray-Object Intersection光线-对象相交"></a>1.2.2 Ray-Object Intersection光线-对象相交</h3></li><li>当相机生成一条光线时，renderer的首要任务是：确定与光线intersect的首个对象和相交的位置。This intersection point is the visible point along the ray, and we will want to simulate the intersection of light with the object at this point. </li></ul><figure class="image-box">                <img src="1.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure><p> 给定光线r,o为光线源点，d表示方向向量，参数t的范围为0到无穷，通过t取不同的值可以得到光线上的任何一点。<br> 在交点的计算中，需测试光线与全部场景对象之间的相交结果，并选取与光线首次相交的对象。<br> 多数场景均由多个对象构成，蛮力进行相机计算将依次测试场景中的各个对象，并选取相交结果最小的t值，但这种方案的计算速度较为缓慢；还可以引入加速结构，并剔除一组对象，进行算法的加速。</p><h3 id="1-2-3-Light-Distribution光照分布"><a href="#1-2-3-Light-Distribution光照分布" class="headerlink" title="1.2.3 Light Distribution光照分布"></a>1.2.3 Light Distribution光照分布</h3><figure class="image-box">                <img src="2.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure><ul><li>较大球体上某点处的能量将小于较小球体，其原因在于相同的光能分布于较大的面积上，特别的，对于半径为r的球体，其表面某点处的能量与1/r^2成比例。</li><li>由于点光源采用各向均等方式辐射能量。因而两球体存储相同光能。</li><li>对于球体表面面积微分dA,其上的光能能够表示为：<figure class="image-box">                <img src="3.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure><br>其中Φ表示光源能量，θ为表面点法线与表面点和光源连线的夹角<figure class="image-box">                <img src="4.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure></li></ul><h3 id="1-2-4Visibility-可见性"><a href="#1-2-4Visibility-可见性" class="headerlink" title="1.2.4Visibility 可见性"></a>1.2.4Visibility 可见性</h3><ul><li>确定是否被遮挡（阴影）</li><li>当着色点与光源之间没有遮挡时，着色点方可被“点亮”<br>确定是否被遮挡：</li><li>1、着色点与光源之间的连线，指向光源——阴影光线（shaow rays）</li><li>2、通过交点计算，算出参数t,确定阴影光线的交点，并通过t的值，确定遮挡关系</li></ul><h3 id="1-2-5表面散射-Surface-Scattering"><a href="#1-2-5表面散射-Surface-Scattering" class="headerlink" title="1.2.5表面散射 Surface Scattering"></a>1.2.5表面散射 Surface Scattering</h3><p>场景中的各对象的材质属性，描述了表面各点处的外观属性，材质通过BRDF定义（双向反射分布函数），而材质决定外观（BSDF决定通用散射行为）</p><figure class="image-box">                <img src="5.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure><p>参数含义：</p><figure class="image-box">                <img src="6.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure>    <h3 id="1-2-6-Indirect-Light-Transport"><a href="#1-2-6-Indirect-Light-Transport" class="headerlink" title="1.2.6 Indirect Light Transport"></a>1.2.6 Indirect Light Transport</h3><figure class="image-box">                <img src="7.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure><h3 id="1-2-7-Ray-Propagation-射线传播"><a href="#1-2-7-Ray-Propagation-射线传播" class="headerlink" title="1.2.7 Ray Propagation 射线传播"></a>1.2.7 Ray Propagation 射线传播</h3><p>渲染环境不一定是真空（vacuum）<br>参与介质介质影响光线传播<br>影响的两种方式：<br>（一）介质在不同的方向上吸收或散射，衰减光线<br>（二）如：介质自发光或者价值沿当前光线相反方向并向其他方向散射光线</p><h2 id="1-3-pbrt-System-Overview-系统总览"><a href="#1-3-pbrt-System-Overview-系统总览" class="headerlink" title="1.3 pbrt:System Overview 系统总览"></a>1.3 pbrt:System Overview 系统总览</h2><p>标准的面向对象构建<br>抽象类针对重要实体进行定义<br>The majority of the system is implemented purely in terms of the interface provided by these abstract base class.(系统的主要内容根据抽象类提供的接口实现)</p><figure class="image-box">                <img src="1573095588456.png" alt="[sorry,图片挂了]" title="[pbrt-v3中的10个抽象类]" class="[samll]">                <p>[pbrt-v3中的10个抽象类]</p>            </figure><p>pbrt网站中有源码以及额外实现的图形、材质等内容的源码</p><h3 id="1-3-1-Phase-of-Execution执行阶段"><a href="#1-3-1-Phase-of-Execution执行阶段" class="headerlink" title="1.3.1 Phase of Execution执行阶段"></a>1.3.1 Phase of Execution执行阶段</h3><p>PBRT程序执行：<br>① 解析用户提供的.pbrt文件（场景描述文件）<br>初始化相应的类→Scene类的实例和Integrator类（此类用于实现算法渲染Scene）的实例<br>② 整个渲染流程</p><figure class="image-box">                <img src="1573096051239.png" alt="[sorry,图片挂了]" title="[pbrt-v3中的10个抽象类]" class="[samll]">                <p>[pbrt-v3中的10个抽象类]</p>            </figure><ul><li>并行相关问题<br>① 读取场景文件以及创建场景都是单线程的，获取场景信息因为不涉及到修改数据，所以可以无视。我们只需要关注修改内存数据的情况。<br>② 请不要在不同步的情况下修改数据<br>③ 对应初始化可以考虑std::call_once函数<br>④ 实用程序类MemoryArena（用于高性能临时内存分配）和RNG（伪随机数生成）也不适合多线程使用; 这些类存储在调用其方法时被修改的状态，并且相互排除的保护修改到其状态的开销相对于它们执行的计算量而言过多。 因此，在上面的SamplerIntegrator :: Render()方法的代码中，实现在堆栈上分配这些类的perthread实例。<br>⑤ 每个线程需要各复制一个Sampler的实例，以保证线程安全<br>⑥ 目前的计算机架构运算除法、平方根和三角函数是最慢的。加法与乘法相比之下要快10~50倍。所以我们可以减少这种数学运算数量来提高性能。例如我们可以提前计算1/v,之后再乘。而不是重复除以v。</li></ul><h3 id="1-3-2-Scene-Representation-场景表达"><a href="#1-3-2-Scene-Representation-场景表达" class="headerlink" title="1.3.2 Scene Representation 场景表达"></a>1.3.2 Scene Representation 场景表达</h3><ul><li><p>PBRT中的main函数→处理argv中提供的命令行参数<br>  → 初始化Option Structure,传给pbrtInit()进行系统内的初始化<br>  → parse（解析）Scene ,创建 Scene、Integrator对象<br>  after rendering→pbrtClaenup()，在系统退出前进行清理</p></li><li><p>ParseFile()  解析Scene</p></li><li><p>Light对象：场景中的光源，指定光的形状和能量分布<br>  场景使用C++标准库（std）的shared_ptr实例向量，存储所有灯光<br>  pbrt使用共享指针跟踪对象被其他实例引用的次数（当最后一个持有实例的引用被销毁时，引用次数为零）<br>  系统中很多部分需要访问光源，因此Scene使其成为公共变量。</p></li><li><p>场景定义后，渲染开始前，进行预处理 Preprocess()</p></li><li><p>Scene提供两个光线图元求交函数：<br>①bool Intersect(const Ray&amp;ray,SurfaceInteraction *insect)const<br>对指定光线进行求交判定，将沿光线与图元相交最近的交点信息保存到SurfaceIntersection结构中<br>②bool IntersectP(const Ray&amp;ray)const<br>仅确定沿光线是否存在交点</p></li></ul><h3 id="1-3-3-Integrator-Interface-and-SamplerIntegrator"><a href="#1-3-3-Integrator-Interface-and-SamplerIntegrator" class="headerlink" title="1.3.3 Integrator Interface and SamplerIntegrator"></a>1.3.3 Integrator Interface and SamplerIntegrator</h3><ul><li><p>渲染场景是由实现了Integrator接口的实例完成的，这其中Integrator是一个抽象基类，提供Render()方法<br>virtual void Render(const Scene &amp;scene)=0;<br>Integrator接口定义在：core/integrator.h中<br>Integrator实用方法定义在：core/integrator.cpp中<br>各类积分器的实现位于Integrator文件目录中</p></li><li><p>Integrator<br> ↓继承<br>SamplerIntegrator (Create in RenderOptions::MakeIntegrator)<br> ↓实现<br>WhittedIntegrator</p></li></ul><p>在SamplerIntegrator中，存储了指向Sampler的指针</p><ul><li>Camera对象：控制相机相关，postion,orientation,filed of view ,focus等</li><li>Film对象：在Camera对象内，控制图像存储</li></ul><h3 id="1-3-4-The-Main-Rendering-Loop"><a href="#1-3-4-The-Main-Rendering-Loop" class="headerlink" title="1.3.4 The Main Rendering Loop"></a>1.3.4 The Main Rendering Loop</h3><ul><li>当Scene、Integrator被指定后，Invoke(调用)Render()开启main rendering loop</li></ul><p>实现：at each of a series of positions on the image plane, the method uses the Camera and the Sampler to generate a ray into the scene and then uses the Li() method to determine the amount of light arriving at the image plane along that ray. This value is passed to the Film, which records the light’s contribution.</p><p>主循环源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">void SamplerIntegrator::Render(const Scene &amp;scene) &#123;</span><br><span class="line">    Preprocess(scene, *sampler);//预处理</span><br><span class="line">    //分块并行渲染图片</span><br><span class="line"></span><br><span class="line">    //计算tiles, _nTiles_,用于并行运算</span><br><span class="line">    Bounds2i sampleBounds = camera-&gt;film-&gt;GetSampleBounds();</span><br><span class="line">    Vector2i sampleExtent = sampleBounds.Diagonal();</span><br><span class="line">    //书中说16*16分块可以解决大部分情况</span><br><span class="line">    const int tileSize = 16;</span><br><span class="line">    //sampleExtent.x + tileSize - 1 整除考虑</span><br><span class="line">    Point2i nTiles((sampleExtent.x + tileSize - 1) / tileSize,</span><br><span class="line">                   (sampleExtent.y + tileSize - 1) / tileSize);</span><br><span class="line">    ProgressReporter reporter(nTiles.x * nTiles.y, &quot;Rendering&quot;);</span><br><span class="line">    &#123;</span><br><span class="line">        ParallelFor2D([&amp;](Point2i tile) &#123;</span><br><span class="line">            // Render section of image corresponding to _tile_</span><br><span class="line"></span><br><span class="line">            //内存池，之后会给Li函数</span><br><span class="line">            MemoryArena arena;</span><br><span class="line"></span><br><span class="line">            //给每个块分配一个Samper实例</span><br><span class="line">            int seed = tile.y * nTiles.x + tile.x;</span><br><span class="line">            std::unique_ptr&lt;Sampler&gt; tileSampler = sampler-&gt;Clone(seed);</span><br><span class="line"></span><br><span class="line">            //计算块的采样边界</span><br><span class="line">            int x0 = sampleBounds.pMin.x + tile.x * tileSize;</span><br><span class="line">            int x1 = std::min(x0 + tileSize, sampleBounds.pMax.x);</span><br><span class="line">            int y0 = sampleBounds.pMin.y + tile.y * tileSize;</span><br><span class="line">            int y1 = std::min(y0 + tileSize, sampleBounds.pMax.y);</span><br><span class="line">            Bounds2i tileBounds(Point2i(x0, y0), Point2i(x1, y1));</span><br><span class="line">            LOG(INFO) &lt;&lt; &quot;Starting image tile &quot; &lt;&lt; tileBounds;</span><br><span class="line"></span><br><span class="line">            //取得指定范围的图片块</span><br><span class="line">            std::unique_ptr&lt;FilmTile&gt; filmTile =</span><br><span class="line">                camera-&gt;film-&gt;GetFilmTile(tileBounds);</span><br><span class="line"></span><br><span class="line">            //开始指定区域的渲染循环</span><br><span class="line">            for (Point2i pixel : tileBounds) &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    ProfilePhase pp(Prof::StartPixel);</span><br><span class="line">                    tileSampler-&gt;StartPixel(pixel);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Do this check after the StartPixel() call; this keeps</span><br><span class="line">                // the usage of RNG values from (most) Samplers that use</span><br><span class="line">                // RNGs consistent, which improves reproducability /</span><br><span class="line">                // debugging.</span><br><span class="line">                if (!InsideExclusive(pixel, pixelBounds))</span><br><span class="line">                    continue;</span><br><span class="line"></span><br><span class="line">                do &#123;</span><br><span class="line">                    //初始化相机采样，存储了时间以及镜头位置的采样值</span><br><span class="line">                    CameraSample cameraSample =</span><br><span class="line">                        tileSampler-&gt;GetCameraSample(pixel);</span><br><span class="line"></span><br><span class="line">                    //生成相机光线</span><br><span class="line">                    //以及光线的pdf</span><br><span class="line">                    RayDifferential ray;</span><br><span class="line">                    Float rayWeight =</span><br><span class="line">                        camera-&gt;GenerateRayDifferential(cameraSample, &amp;ray);</span><br><span class="line">                    ray.ScaleDifferentials(</span><br><span class="line">                        1 / std::sqrt((Float)tileSampler-&gt;samplesPerPixel));</span><br><span class="line">                    ++nCameraRays;</span><br><span class="line"></span><br><span class="line">                    //估算当前相机光线辐射度</span><br><span class="line">                    Spectrum L(0.f);</span><br><span class="line">                    if (rayWeight &gt; 0) L = Li(ray, scene, *tileSampler, arena);</span><br><span class="line"></span><br><span class="line">                    //对渲染出错误结果的处理，log相应信息</span><br><span class="line">                    if (L.HasNaNs()) &#123;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; StringPrintf(</span><br><span class="line">                            &quot;Not-a-number radiance value returned &quot;</span><br><span class="line">                            &quot;for pixel (%d, %d), sample %d. Setting to black.&quot;,</span><br><span class="line">                            pixel.x, pixel.y,</span><br><span class="line">                            (int)tileSampler-&gt;CurrentSampleNumber());</span><br><span class="line">                        L = Spectrum(0.f);</span><br><span class="line">                    &#125; else if (L.y() &lt; -1e-5) &#123;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; StringPrintf(</span><br><span class="line">                            &quot;Negative luminance value, %f, returned &quot;</span><br><span class="line">                            &quot;for pixel (%d, %d), sample %d. Setting to black.&quot;,</span><br><span class="line">                            L.y(), pixel.x, pixel.y,</span><br><span class="line">                            (int)tileSampler-&gt;CurrentSampleNumber());</span><br><span class="line">                        L = Spectrum(0.f);</span><br><span class="line">                    &#125; else if (std::isinf(L.y())) &#123;</span><br><span class="line">                          LOG(ERROR) &lt;&lt; StringPrintf(</span><br><span class="line">                            &quot;Infinite luminance value returned &quot;</span><br><span class="line">                            &quot;for pixel (%d, %d), sample %d. Setting to black.&quot;,</span><br><span class="line">                            pixel.x, pixel.y,</span><br><span class="line">                            (int)tileSampler-&gt;CurrentSampleNumber());</span><br><span class="line">                        L = Spectrum(0.f);</span><br><span class="line">                    &#125;</span><br><span class="line">                    VLOG(1) &lt;&lt; &quot;Camera sample: &quot; &lt;&lt; cameraSample &lt;&lt; &quot; -&gt; ray: &quot; &lt;&lt;</span><br><span class="line">                        ray &lt;&lt; &quot; -&gt; L = &quot; &lt;&lt; L;</span><br><span class="line"></span><br><span class="line">                    // Add camera ray&apos;s contribution to image</span><br><span class="line">                    filmTile-&gt;AddSample(cameraSample.pFilm, L, rayWeight);</span><br><span class="line"></span><br><span class="line">                   //释放内存池</span><br><span class="line">                    arena.Reset();</span><br><span class="line">                &#125; while (tileSampler-&gt;StartNextSample());</span><br><span class="line">            &#125;</span><br><span class="line">            LOG(INFO) &lt;&lt; &quot;Finished image tile &quot; &lt;&lt; tileBounds;</span><br><span class="line"></span><br><span class="line">            //将图片块合并到图片上去</span><br><span class="line">            camera-&gt;film-&gt;MergeFilmTile(std::move(filmTile));</span><br><span class="line">            reporter.Update();</span><br><span class="line">        &#125;, nTiles);</span><br><span class="line">        reporter.Done();</span><br><span class="line">    &#125;</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;Rendering finished&quot;;</span><br><span class="line"></span><br><span class="line">    //保存图片到文件</span><br><span class="line">    camera-&gt;film-&gt;WriteImage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-5-An-Integrator-for-Whitted-Ray-Tracing"><a href="#1-3-5-An-Integrator-for-Whitted-Ray-Tracing" class="headerlink" title="1.3.5 An Integrator for Whitted Ray Tracing"></a>1.3.5 An Integrator for Whitted Ray Tracing</h3><ul><li></li></ul><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=501468332&auto=1&height=32"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PBRT-CHAPTER-1&quot;&gt;&lt;a href=&quot;#PBRT-CHAPTER-1&quot; class=&quot;headerlink&quot; title=&quot;PBRT CHAPTER_1&quot;&gt;&lt;/a&gt;PBRT CHAPTER_1&lt;/h1&gt;&lt;p&gt;*Introduction&lt;br&gt;PBRT(
      
    
    </summary>
    
    
      <category term="Computer-Science" scheme="http://yoursite.com/categories/Computer-Science/"/>
    
      <category term="RayTracing" scheme="http://yoursite.com/categories/Computer-Science/RayTracing/"/>
    
    
      <category term="RayTracing" scheme="http://yoursite.com/tags/RayTracing/"/>
    
      <category term="PBRT" scheme="http://yoursite.com/tags/PBRT/"/>
    
  </entry>
  
  <entry>
    <title>开发工具推荐及相关使用</title>
    <link href="http://yoursite.com/2019/11/04/Basic_Software_Use/"/>
    <id>http://yoursite.com/2019/11/04/Basic_Software_Use/</id>
    <published>2019-11-04T01:56:27.000Z</published>
    <updated>2019-11-05T12:07:56.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发工具及使用"><a href="#开发工具及使用" class="headerlink" title="开发工具及使用"></a>开发工具及使用</h1><p>+++</p><h3 id="1-listary"><a href="#1-listary" class="headerlink" title="1. listary"></a>1. listary</h3><ul><li>双击Ctrl全局搜索</li><li>在文件管理器中双击空白处进行列表呼出</li></ul><h3 id="2-cmd"><a href="#2-cmd" class="headerlink" title="2.cmd"></a>2.cmd</h3><ul><li>在当前文件目录的显示栏下输入 cmd ,即可在当前路径下打开命令行</li></ul><h3 id="3-stb-image简单图像库"><a href="#3-stb-image简单图像库" class="headerlink" title="3,stb_image简单图像库"></a>3,stb_image简单图像库</h3><ul><li><p>重点关注三个头文件</p></li><li><figure class="image-box">                <img src="1570780034511.png.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure></li></ul><h3 id="4-Windows-OS"><a href="#4-Windows-OS" class="headerlink" title="4.Windows OS"></a>4.Windows OS</h3><ul><li>Shift+F10:鼠标右键快捷键</li><li>Win+Ctrl+←/→：窗口切换，保命技巧</li></ul><h3 id="5-RenderDoc"><a href="#5-RenderDoc" class="headerlink" title="5.RenderDoc"></a>5.RenderDoc</h3><ul><li>可集成到VS或者Unity3D中</li></ul><h3 id="6-Typora"><a href="#6-Typora" class="headerlink" title="6. Typora"></a>6. Typora</h3><ul><li>Ctrl+/：源代码模式进入或者退出</li></ul><h3 id="7-Visual-Studio-Code"><a href="#7-Visual-Studio-Code" class="headerlink" title="7. Visual Studio Code"></a>7. Visual Studio Code</h3><ul><li>Ctrl+Shift+P:调出主命令框</li><li>Ctrl +K选中后，再按V：预览markdown效果</li></ul><h3 id="8-Scons"><a href="#8-Scons" class="headerlink" title="8. Scons"></a>8. Scons</h3><ul><li>基于python的软件构建工具</li></ul><h3 id="9-Python"><a href="#9-Python" class="headerlink" title="9.Python"></a>9.Python</h3><p>在同一计算机上同时配置两个不同版本的Python时，例如Python2.7以及Python3.6两个版本，可以在Python27文件夹下将python.exe文件更名为python27.exe，然后在用户环境变量下的Path下维护两个版本的Python地址，每个版本两个地址（一个Python文件夹地址，一个Script地址）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开发工具及使用&quot;&gt;&lt;a href=&quot;#开发工具及使用&quot; class=&quot;headerlink&quot; title=&quot;开发工具及使用&quot;&gt;&lt;/a&gt;开发工具及使用&lt;/h1&gt;&lt;p&gt;+++&lt;/p&gt;
&lt;h3 id=&quot;1-listary&quot;&gt;&lt;a href=&quot;#1-listary&quot; cl
      
    
    </summary>
    
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
      <category term="开发工具" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>VS使用及错误合集</title>
    <link href="http://yoursite.com/2019/11/04/Basic_Software_Use_VS/"/>
    <id>http://yoursite.com/2019/11/04/Basic_Software_Use_VS/</id>
    <published>2019-11-04T01:56:27.000Z</published>
    <updated>2019-11-05T08:27:28.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-错误合集"><a href="#1-错误合集" class="headerlink" title="1.错误合集"></a>1.错误合集</h1><hr><h3 id="1-1-ErrorLINK2019无法解析的外部符号-WinMain-16"><a href="#1-1-ErrorLINK2019无法解析的外部符号-WinMain-16" class="headerlink" title="1.1 .ErrorLINK2019无法解析的外部符号_WinMain@16"></a>1.1 .ErrorLINK2019无法解析的外部符号_WinMain@16</h3><ul><li>原因：无法找到适当的程序入口函数，其中Windows程序和控制台程序Console的入口程序不一致，应该在项目配置信息中选择适当预处理器以及链接器中合适的子系统。</li></ul><ul><li><figure class="image-box">                <img src="VS1.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure></li><li><p>解决：</p></li></ul><ul><li><figure class="image-box">                <img src="VS2.png" alt="[sorry,图片挂了]" title="[image]" class="[samll]">                <p>[image]</p>            </figure></li></ul><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h1><hr><ul><li>Ctrl+Shift+B：生成解决方案，形成可执行文件。</li><li>生成可执行文件后有两种形式，其中一种是调试，一种是直接执行不调试</li><li>(F5或Alt+F5)在调试程序过程中，若遇到断点，会停止在断点处，等待继续运行的指令，当程序运行完毕后不会直接退出，而会暂停程序。</li><li>(Ctrl+F5)直接执行程序（不调试），完全忽略断点，程序运行完毕后直接结束程序。</li></ul><hr><h2 id="在VS2017中安装配置OpenGL教程："><a href="#在VS2017中安装配置OpenGL教程：" class="headerlink" title="在VS2017中安装配置OpenGL教程："></a>在VS2017中安装配置OpenGL教程：</h2><p><a href="http://www.cnblogs.com/flylinmu/p/7823019.html" target="_blank" rel="noopener">http://www.cnblogs.com/flylinmu/p/7823019.html</a></p><p>注意：</p><ul><li><p>（1）.在VS中对于项目进行属性配置时，右键点击解决方案中的项目名称，选择“属性配置”。</p></li><li><p>（2）.在VS2017中新建一个Windows控制台项目时，会自动生成一个pch.h文件，项目将其默认为预编译头文件，当项目较大时，可以在pch.h头文件中加入大量的宏定义，便于后期的维护更新，但是当项目较小时，可以在项目配置中，选择C/C++,将预编译头省略。</p></li><li><p>相关博客：<br><a href="http://www.blog.csdn.net/weixin_43074474/article/details/89520392" target="_blank" rel="noopener">http://www.blog.csdn.net/weixin_43074474/article/details/89520392</a></p></li></ul><hr><h2 id="VS快捷键"><a href="#VS快捷键" class="headerlink" title="VS快捷键"></a>VS快捷键</h2><ul><li>Alt+→：代码提示代码</li><li>注释代码：Ctrl+K选中后再C</li><li>取消注释代码：Ctrl+K选中后再U</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-错误合集&quot;&gt;&lt;a href=&quot;#1-错误合集&quot; class=&quot;headerlink&quot; title=&quot;1.错误合集&quot;&gt;&lt;/a&gt;1.错误合集&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-1-ErrorLINK2019无法解析的外部符号-WinMain-16&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Visual Studio" scheme="http://yoursite.com/tags/Visual-Studio/"/>
    
  </entry>
  
  <entry>
    <title>Basic Tips about CS or SE</title>
    <link href="http://yoursite.com/2019/11/04/Tips/"/>
    <id>http://yoursite.com/2019/11/04/Tips/</id>
    <published>2019-11-04T01:56:27.000Z</published>
    <updated>2019-11-05T04:47:44.062Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-HDR（High-Dynamic-Range）"><a href="#1-HDR（High-Dynamic-Range）" class="headerlink" title="1. HDR（High Dynamic Range）"></a>1. HDR（High Dynamic Range）</h3><ul><li>相比普通的图像，可以提供更多的动态范围和图像细节，根据不同的曝光时间的LDR（Low Dynamic Range）图像，相对应每个曝光时间对应最佳细节的LDR图像来合成最终的HDR图像，能够更好的反映除真实环境中的视觉效果。<a id="more"></a></li><li><ul><li>简单来说，就是一张图片中尽可能的显示最亮和最暗的地方。</li></ul></li><li>通过将拍出的几张不同曝光的照片，将每张照片曝光正常的部分保留，合成一张，就得到了一条了一张HDR图像。</li></ul><h3 id="2-HDR合成"><a href="#2-HDR合成" class="headerlink" title="2. HDR合成"></a>2. HDR合成</h3><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><ul><li>Unity中对于动态物体，例如人物等，使用Light Probe对于间接光照进行处理，Light Probe（采样点）对环境进行采样（发生在预处理阶段），在运行阶段，渲染器从邻近的采样点中取值，并对点进行插值处理。</li></ul><h3 id="4-计算机图形学（Computer-Graphics）和计算机视觉-Computer-Version"><a href="#4-计算机图形学（Computer-Graphics）和计算机视觉-Computer-Version" class="headerlink" title="4. 计算机图形学（Computer Graphics）和计算机视觉(Computer Version)"></a>4. 计算机图形学（Computer Graphics）和计算机视觉(Computer Version)</h3><ul><li>计算机图形（Computer Graphics）和计算机视觉（Computer Vision）是一对孪生兄弟，二者互为逆过程。</li><li><ul><li>计算机图形是预先知道3D物体的形状、位置、材料构成，以及场景的灯光和相机，然后渲染出场景。</li></ul></li><li>计算机视觉是已知拍到的图像，从中推断出有哪些物体，它们由什么材料制成，以及它们的3D位置和方向。</li></ul><h3 id="5-Mitsuba"><a href="#5-Mitsuba" class="headerlink" title="5. Mitsuba"></a>5. Mitsuba</h3><ul><li>一个面向研究用的开源软件，基于PBRT(Physically based rendering technology) 根据几何光学的物理性质编程实现</li><li>性能：实现了大多数常见的渲染算法</li><li>鲁棒性（Robustness）:采用底层算法（underlying algorithm）</li><li>可扩展性：可以并行计算，用大型计算簇实现与优化加速</li><li>限制：对于光的波特性无法很好的表现</li><li>极其模块化，它由一小组核心库和100多种不同的插件组成，这些插件实现了从材料和光源到完整渲染算法的功能。</li><li>与其他开源渲染器相比，Mitsuba非常重视实验渲染技术，例如Metropolis LightTransport的路径配方和体积建模方法。 因此，对于那些想要尝试这种尚未进入主流渲染器的技术的人来说，它可能是真正感兴趣的，它也为这一领域的研究提供了坚实的基础。</li></ul><h3 id="6-Tips"><a href="#6-Tips" class="headerlink" title="6.Tips"></a>6.Tips</h3><ul><li><p>jpg不支持透明度，有损压缩的图像格式，有损压缩会使得原始图片数据质量下降，也使得其占用空间小，在网页应用中加速速度快。</p></li><li><p>png支持透明度，无视压缩的图像格式，能在保证不失真的情况下尽可能压缩图像文件的大小，因此图像质量高，在一些贴纸应用中大多采用png图片。</p></li><li><p>Markdown：一种使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使得普通文本具有一定的格式。<br>Markdown具有一系列的衍生版本，用于扩展Markdown功能（例如：表格，脚注，内嵌HTML等）</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-HDR（High-Dynamic-Range）&quot;&gt;&lt;a href=&quot;#1-HDR（High-Dynamic-Range）&quot; class=&quot;headerlink&quot; title=&quot;1. HDR（High Dynamic Range）&quot;&gt;&lt;/a&gt;1. HDR（High Dynamic Range）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;相比普通的图像，可以提供更多的动态范围和图像细节，根据不同的曝光时间的LDR（Low Dynamic Range）图像，相对应每个曝光时间对应最佳细节的LDR图像来合成最终的HDR图像，能够更好的反映除真实环境中的视觉效果。
    
    </summary>
    
    
      <category term="Computer-Science" scheme="http://yoursite.com/categories/Computer-Science/"/>
    
      <category term="Basic Tips" scheme="http://yoursite.com/categories/Computer-Science/Basic-Tips/"/>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>Hello Graphic World</title>
    <link href="http://yoursite.com/2019/11/04/hello-world/"/>
    <id>http://yoursite.com/2019/11/04/hello-world/</id>
    <published>2019-11-04T01:56:27.000Z</published>
    <updated>2019-11-05T03:23:37.038Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="创建新的分页"><a href="#创建新的分页" class="headerlink" title="创建新的分页"></a>创建新的分页</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page XXX</span><br></pre></td></tr></table></figure><h3 id="创建新的博文"><a href="#创建新的博文" class="headerlink" title="创建新的博文"></a>创建新的博文</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new XXX</span><br></pre></td></tr></table></figure><ul><li>使用图像资源的相对路径的话，需要在yml文件中设置，并且在_posts文件中创建一个与博文名称一致的文件夹，并将图像资源放置其中。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
